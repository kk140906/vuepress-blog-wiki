---
title: 3. 字符串、向量与数组
date: 2017-08-25
article: false
category:
  - C++
tag:
  - 字符串
  - vector
  - 数组
  - string
---

## 3.1 命名空间的 using 声明

通过 _using_ 声明可以将某个标准库的东西引入到当前作用域，注意尽量不要在头文件中使用 _using_ 声明引入标准库的太多东西，这是因为只要该头文件被别的文件包含时会将头文件的内容拷贝到对应的文件中。

_using_ 声明有两种使用方式：

- 引入某些内容 `using namespace::name;`，例如 `using std::cout;`
- 引入命名空间下的所有内容 `using namespace namespace_name`，例如 `using namespace std;`

## 3.2 标准库类型 string

### 3.2.1 定义和初始化 string 对象

_string_ 是 C++ 标准库中的字符串库，**类对象的初始化分为直接初始化和拷贝初始化**，一个 _string_ 对象常用以下方式进行初始化

:::center

| 创建对象                                   | 说明                                            |
| :----------------------------------------- | :---------------------------------------------- |
| string s1                                  | 直接初始化，s1 是空字符串                       |
| string s2(s1) <br>string s2 = s1           | 拷贝初始化，s2 是 s1 的副本                     |
| string s3("hello") <br>string s3 = "hello" | 拷贝初始化，s3 是字面值"hello"的副本            |
| string s4(n,'c')                           | 直接初始化，s4 是由连续 n 个字符‘c 组成的字符串 |

:::

#### 3.2.2 string 对象的操作

下表列举了 _string_ 对象常用的操作

| 操作                                                    | 说明                                                                                                                                                                                              |
| :------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| ostream << s<br>istream >> s                            | 输入输出流操作,返回输入输出流的左值引用                                                                                                                                                           |
| **getline(istream,s)**<sub>易与 cin.getline()混淆</sub> | **从输入流 istream 中读取一行内容，写入到字符串 s 中。<br>getline 遇到换行符就停止读取并返回结果，读取的内容也包括换行符，<br> 但是写入到字符串 s 中时将换行符丢弃了，返回 istream 的左值引用。** |
| s.empty()                                               | 判断字符串 s 是否为空，空为 `true`                                                                                                                                                                |
| s.size()                                                | 返回字符串 s 的字符个数，返回值类型是 _string::size_type_                                                                                                                                         |
| s[n]                                                    | 返回字符串中 s 第 n 个字符的引用，n 从 0 开始                                                                                                                                                     |
| s1 + s2                                                 | 实现两个字符串的拼接,<br>注意+两侧运算对象至少要有一个是 _string_ 类型的对象,<br>而非 _string_ 对象的运算必须要能够转换成 _string_ 对象                                                           |
| s1 = s2                                                 | 赋值操作，注意与初始化的区别                                                                                                                                                                      |
| 比较运算(==,!=,<,<=,>,>=)                               | 大小写敏感，按照字符在字典中的顺序进行比较                                                                                                                                                        |

从输入流 _cin_ 中读取字符串时，_string_ 对象会忽略输入字符开头的空白符，从第一个真正的字符开始读取，直到遇到下一个空白符为止。

_string_ 标准库定义了新的类型 _size_type_，引入该类型的主要目的是使标准库的数据类型与机器类型无关。_string::size_type_ 是一个足以放下任何 _string_ 对象大小的<u>无符号的类型值</u>，注意不要与 _int_ 类型混用，容易导致不期望的结果。例如 `s.size() < n`，如果 n 为负数，那么将 n 会被转换成一个非常大的无符号数值，那么比较结果可能就永远是 _true_。

字符串间的比较运算是按照字典序进行比较的，而且大小写敏感，对于两个字符的比较有下面三个常用规则：

1. 只有当两个字符串长度相同且对应位置上的字符都相同才能说明两个字符串相等；
2. 两个字符串第一个不同字符的字典序决定了两个字符串之间的大小，例如 _"ab" < "ba"_，因为字符 a < 字符 b。特别的，如果一个较短的字符串的每一个字符都与较长的字符串相等，那么较短的字符串小于较长的字符串，例如 "ab < abc",两个字符串中第一个不同的字符为：“ab”后面的字符是'\0',而"abc" 后面的字符'c'，根据 ASCII 码值决定大小关系。

:::tip

由于历史原因，C++ 语言中的字符串字面值并不是 _string_ 对象，字符串字面值与 _string_ 是不同的类型。

:::

### 3.2.3 处理 string 对象中的字符

要处理 _string_ 对象中的字符主要分两步，首先定位到需要处理的字符，然后对这个字符进行处理。定位需要处理的字符可以使用下标“[ ]” 运算符进行随机访问，也可以使用迭代器进行访问，如果要对字符串的每一个字符都操作还可以使用 **范围 for** <Badge text="C++11" type="info" />的语法。对字符的处理函数定义在 _cctype_ 这个头文件中。

:::center

| 操作        | 说明                          | 操作       | 说明                                  |
| :---------- | :---------------------------- | :--------- | :------------------------------------ |
| isalnum(c)  | 判断字符 c 是否是字母或者数字 | isalpha(c) | 判断字符 c 是否是字母                 |
| iscntrl(c)  | 判断字符 c 是否是控制字符     | isdigit(c) | 判断字符 c 是否是数字                 |
| isxdigit(c) | 判断字符 c 是否是十六进制数字 | islower(c) | 判断字符 c 是否是小写字母             |
| isupper(c)  | 判断字符 c 是否是大写字母     | isgraph(c) | 判断字符 c 是否是可以打印的非空格字符 |
| ispunct(c)  | 判断字符 c 是否是标点符号     | isalnum(c) | 判断字符 c 是否是字母或者数字         |
| isprint(c)  | 判断字符 c 是否是可打印字符   | isspace(c) | 判断字符 c 是否是空白字符             |
| tolower(c)  | 将字符 c 转换为小写字母       | toupper(c) | 将字符 c 转换为大写字母               |

:::

:::tip

'[ ]'下标运算符接收的参数类型是 _string::size_type_，使用其进行随机访问时务必保证其索引位置的正确性。

:::

## 3.3 标准库类型 vector

### 3.3.1 定义和初始化 vector 对象

_vector_ 是标准库中容器的一种，是一个类模板，类模板既不是类也不是函数，在编译时由编译器根据模板实例化一个容器类，因此在使用类模板时需要指定实例化的容器中存储的数据类型。下表为定义和初始化 _vector_ 对象的基本方法。

| 初始化<sub>(T 表示存储的数据类型)</sub>                            | 说明                                                                        |
| :----------------------------------------------------------------- | :-------------------------------------------------------------------------- |
| vector&lt;T&gt; v1                                                 | 直接初始化，定义空的 _vector_                                               |
| vector&lt;T&gt; v2(v1) <br> vector&lt;T&gt; v2 = v1                | 拷贝初始化，将 v1 中的所有元素拷贝到 v2 中,<br> v1 与 v2 中元素类型必须相同 |
| vector&lt;T&gt; v3(n,val)                                          | 直接初始化，定义含有 n 个重复 val 的 _vector_                               |
| vector&lt;T&gt; v4(n)                                              | 直接初始化，定义含有 n 个元素的 _vector_,每个元素执行默认初始化             |
| vector&lt;T&gt; v5{a,b,c,...} <br>vector&lt;T&gt; v5 = {a,b,c,...} | 使用初始化列表直接初始化，定义含有 a,b,c,...元素的 _vector_                 |

在某些情况下，初始化的真实含义，取决于传递初始值时使用的是花括号还是圆括号。

- 如果是圆括号，那么编译器会认为圆括号内的值是被用来构造 _vector_ 对象的；
- 如果是花括号，那么编译器会认为花括号内的值被用来进行列表初始化；而如果提供值的不能用来进行列表初始化，那么就会用提供的值尝试去进行构造 _vector_ 对象。

### 3.3.2 向 vector 对象中添加元素

对于 _vector_ 对象，直接初始化适用于三种情况：

1. 初始值已知且数量较少；
2. 初始值是另个一个 _vector_ 对象的副本；
3. 所有元素的初始值都一样

在更多的情况下都是创建一个空的 _vector_ 对象，然后通过 _push_back( )_ 等函数将元素添加到 _vector_ 对象中。

### 3.3.3 其他 vector 操作

_vector_ 对象的常用操作如下：

| 操作                      | 说明                                                                            |
| ------------------------- | ------------------------------------------------------------------------------- |
| v.empty( )                | 判断 _vector_ 是否为空                                                          |
| v.size( )                 | 返回 _vector_ 中元素个数,类型为 `vector<T>::size_type`                          |
| v.push_back(e)            | 将元素 e 添加到 _vector_ 的最后                                                 |
| v[n]                      | _vector_ 支持通过下标随机访问，返回的是第 n 个位置的引用                        |
| 比较运算(==,!=,<,<=,>,>=) | 按照字典序比较，<br/>当两个 _vector_ 元素个数相同，且对应位置元素均相等时才相等 |

:::tip

'[ ]'下标运算符接收的参数类型是 _vector&lt;T&gt;::size_type_，使用其进行随机访问时务必保证其索引位置的正确性。下标运算符是用于访问已经存在的元素，不能用于添加元素。
试图通过下标访问一个不存在的元素将会引发错误，这种错误无法在编译时发现，而是在运行时产生错误，这种错误的下标越界访问就是造成“缓冲区溢出”的方式之一，容易导致程序不安全。

:::

## 3.4 迭代器介绍

通过下标运算符可以访问 _string_ 对象中的字符或者 _vector_ 对象中的元素，但是某些情况却无法使用下标运算符访问。C++ 定义了一种更为通用的机制来实现这个目的，这就是迭代器。标准库中的所有容器都支持迭代器操作，但是只有有限的几个容器支持下标运算符。迭代器的行为类似于指针，提供了对对象的间接访问。

### 3.4.1 使用迭代器

与指针不同，获取迭代器不是通过 `&`，而是通过可以返回迭代器的成员获取，例如 _begin()_ 和 _end()_ 等成员函数。其中 _begin()_ 函数返回容器的首元素的迭代器，_end()_ 函数返回容器尾元素后面一个位置的迭代器，又称为尾后迭代器或者尾迭代器。如果容器为空，那么 _begin()_ 和 _end()_ 返回的都是尾后迭代器。

标准迭代器具有下面的操作

:::center

| 操作             | 说明                                                                                               |
| :--------------- | :------------------------------------------------------------------------------------------------- |
| \*iter           | 返回 iter 指向的元素的引用                                                                         |
| iter->mem        | 解引用 iter,并获取该元素中名为 mem 的成员，类似于(\*iter).mem                                      |
| ++iter or iter++ | 递增 iter,令其指向下一个元素                                                                       |
| --iter or iter-- | 递减 iter，令指向前一个元素，<br>注意前向迭代器不能执行该操作，例如 forward_list&lt;T&gt; 的迭代器 |

:::

**<u>只有当迭代器指向某个元素，或者指向容器中尾元素的后一个位置才能算作有效的迭代器。</u>**

与指针类似，解引用迭代器必须保证迭代器合法且确实指向某个元素，否则解引用操作是未定义的行为。**同时，对于尾后迭代器，我们不能再对其进行递增和解引用操作。**

标准库类型中使用 _iterator_ 和 _const_iterator_ 来区分迭代器的类型，_iterator_ 是普通的迭代器，可以访问和修改所指向的元素，而 _const_iterator_ 是常量迭代器，只能访问，不能修改所指向的元素。对于一个常量的容器对象只能使用 _const_iterator_ 进行访问，而非常量的容器则两种类型均可访问。与 _begin()_ 和 _end()_ 功能类似，C++ 11 引入了新的 _cbegin()_ 和 _cend()_ 函数来获取 _const_iterator_ 类型的迭代器<Badge text="C++11" type="info"/>。

:::danger

记住，迭代器有无效和有效之分，有些操作会使迭代器失效(第 9 章会介绍迭代器的失效情形)。因此，不要在使用了迭代器的循环体中改变迭代器所属容器的元素个数。

:::

### 3.4.2 迭代器运算

迭代器可以进行的运算与指针类似，下表是 _vector_ 和 _string_ 迭代器支持的运算操作

| 操作                      | 说明                                                                                                                                        |
| :------------------------ | :------------------------------------------------------------------------------------------------------------------------------------------ |
| iter + n                  | 返回迭代器 iter 向前移动 n 个位置后的迭代器，<br>返回的结果要么指向某个元素，要么是尾后迭代器                                               |
| iter - n                  | 返回迭代器 iter 往回移动 n 个位置后的迭代器，<br>返回的结果要么指向某个元素，要么是尾后迭代器                                               |
| iter += n                 | iter 向前移动 n 个位置后的结果重新赋值给 iter                                                                                               |
| iter -= n                 | iter 往回移动 n 个位置后的结果重新赋值给 iter                                                                                               |
| iter1 - iter2             | 迭代器相减的结果为两个迭代器相距的距离，<br> 结果类型是带符号的 **_difference_type_**。<br>注意两个迭代器必须指向同一个容器或者是尾后迭代器 |
| 比较运算(==,!=,<,<=,>,>=) | 比较的迭代器必须指向同一个容器或者是尾后迭代器                                                                                              |

:::danger

与两个指针(地址)相加是未定义的行为类似，两个迭代器相加也是未定义的行为。

:::

使用迭代器运算的一个经典算法是二分搜索算法，二分搜索算法在**有序序列**中查找某个给定的值。二分搜索的主要步骤为：

- 从中间位置开始查找，如果中间位置就是要找的值，则不再进行后面的操作，否则，继续下面的步骤；
- 如果给定的值小于中间值，则在前半部分继续寻找，未找到则重复前面的过程；
- 如果给定的值大于中间值，则在后半部分继续寻找，未找到则重复前面的过程；

```cpp
auto begin = text.begin();
auto end = text.end();
auto mid = begin + (end - begin) / 2;
while（value != *mid && mid != end）{
    if(value  < *mid){
        end = mid;
    } else {
      begin = mid + 1;
    }
    mid = begin + (end - begin) / 2;
}
```

## 3.5 数组

数组与 _vector_ 类似，也能够存储同类型的元素。但是数组的大小确定不变，不能随便向数组中增加元素。

### 3.5.1 定义和初始化内置数组

数组是一种复合类型，声明形式是 “array [n]”。编译时，数组的元素个数必须是常量表达式。默认情况下，数组的元素被默认初始化。 定义数组的时候必须指定数组元素的类型，不能通过 _auto_ 去推断出数组类型，此外，和 _vector_ 类似，数组的元素必须是对象，这就意味着数组元素不能是引用，因此不存在引用的数组。

```cpp
constexpr unsigned sz = 42; // 常量表达式
unsigned cnt = 42; // 非常量表达式

// 定义和初始化数组
int arr1[10]; // arr1含有10个int类型的元素
int *arr2[sz]; // arr2含有42个int *类型的元素
// int arr3[cnt]; // 错误，cnt并不是常量表达式，不能用来定义数组
int arr4[get_size()]; // get_size()为函数调用，当结果为constexpr时是合法的

// 列表初始化:
// 使用列表初始化可以忽略数组的元素个数，此时数组的大小就是初始化的元素个数
// 如果定义时指定了数组大小，那么初始化列表的元素个数不能超过指定的数组大小
// 初始化列表的元素被用来初始化数组前面的元素，剩下的元素被初始化为默认值
int arr5[] = {0,1,2,3}; // 用元素0,1,2,3初始化数组5
int arr6[4] = {0,1}; // 数组元素0,1,0,0
// int arr7[4] = {0,1,2,3,4}; // 初始化列表元素过多，错误
```

字符数组除了上面的初始化方式外还可以使用字符串字面值对其进行初始化，初始化时会将字符串末尾的空字符拷贝到字符数组中，所以使用字符串字面值初始化数组的大小时需要考虑字符串末尾的空字符。

数组无法进行整体的拷贝，除了列表初始化时，数组也无法进行整体的赋值。

上面提过数组的元素必须是对象，不存在引用的数组，但是数组本身是对象，所以存在数组的引用。

对于复杂类型的数组声明解读，默认情况下，类型修饰符从右向左依次绑定，但是要更好的理解数组的声明，更好的办法是从数组的名字开始按照由内向外的顺序解读。

```cpp
// 类型修饰从右向左依次绑定，
// []表明定义的是一个含有10个元素的数组，
// 数组的名字是 arr,
// 数组元素的类型是 int *
int * arr[10];

// int &arr[10]; 错误，定义的数组元素类型是引用，但是不存在引用的数组

// 从内向外解读
// 圆括号内部表明定义的是指针，
// 指针所指向的对象是一个含有10个元素的数组,
// 数组的元素类型是 int
int (*pArr)[10] = &arr;

// 与指向数组的指针解读类似
int (&rArr)[10] = arr;

// rArr是一个含有10个元素数组的引用，
// 数组的元素类型是int *
int *(&rArr)[10] = arr;
```

### 3.5.2 访问数组元素

访问数组的元素与 _vector_ 和 _string_ 类似，也可以通过范围 _for_ 语句和下标运算符来访问。在使用数组下标的时候建议使用与机器类型无关的 _size_t_ 类型，该类型定义在 _cstddef_ 头文件中。同样的，使用数组的下标运算符访问数组元素时也需要防止下标越界，以防止缓冲区溢出错误。

### 3.5.3 指针和数组

通常情况下，通过取地址符 `&` 可以获取对象的地址，同样的，对数组某个位置的元素使用取地址符也可以获取其地址。特别的是，在 C++ 中数组名被用来表示指向数组第一个元素的地址，它是一个常量指针，无法更改其所指向的对象，==**因此在使用数组的时候编译器通常会将数组名转换成指针。**==

根据上述特性，这会导致在使用自动类型推断时出现不同，当使用 _auto_ 进行类型推导时，推导的类型是指针类型，而使用 _decltype_ 推导时，推导的类型仍为数组。

指针的行为与迭代器非常类似，C++11 后引入了 _begin()_ 和 _end()_ 函数，但是由于数组不是类，因此这两个函数不是成员函数，而容器的这两个函数是成员函数，数组的这两个函数定义在 _iterator_ 的头文件中。与迭代器类似，指向同一个数组的两个指针也可以做相减运算，结果为它们之间的距离，类型为带符号的 _ptrdiff_t_ ，是与机器无关的标准类型，定义在 _cstddef_ 头文件中。

:::info

对于数组与其他容器需要区别的是：

对于数组的下标可以接受的索引类型是有符号类型的，负值表示指针往回移动，只要移动后指向的对象还是数组的元素则是正确的；而对于 _vector_ 等容器中使用的下标运算则是无符号类型的。

:::

### 3.5.4 C 风格的字符串

在 C++ 中，字符串字面值是一种通用结构实例，继承自 C 风格的字符串，按照这个风格写得字符串是被保存到字符数组中，并以空字符结尾，因此，它不是 _string_ 对象。_cstring_ 头文件中提供了 C 标准库中字符串的常用操作。

| 操作<sub>（不会检测字符串的正确性）</sub> | 详细                                                                                      |
| :---------------------------------------- | :---------------------------------------------------------------------------------------- |
| strlen(p)                                 | 计算指针 p 指向的字符串的长度，不包含结尾的空字符                                         |
| strcmp(p1,p2)                             | 比较两个指针指向的字符串的相等性，<br>p1 == p2,返回 0；p1 > p2,返回正数；p1 < p2,返回负数 |
| strcat(p1,p2)                             | 将 p2 指向的字符串附加到 p1 指向的字符串之后，返回 p1                                     |
| strcpy(p1,p2)                             | 将 p2 指向的字符串拷贝到 p1 指向的位置，返回 p1                                           |

### 3.5.5 与旧代码的接口

为了与 C 语言的代码兼容，C++ 的 _string_ 对象的操作中可以与 C 风格的字符串进行混用，C++为此对 _string_ 对象进行了下面的优化设计：

- 允许使用字符串字面值初始化 _string_ 对象；
- 允许使用 C 风格的字符串来初始化 _string_ 对象或为 _string_ 对象赋值；
- 在 _string_ 对象的加法操作中允许其中一个对象是 C 风格的字符串；
- 在 _string_ 对象的复合赋值运算(如+=)中 允许右侧的运算对象是 C 风格的字符串；
- 提供 _c_str()_ 成员函数将 _string_ 对象转换为 C 风格的字符串，无法保证转换后的结果一直有效，建议对结果进行拷贝。

## 3.6 多维数组

C++ 并没有多维数组，通常提到的多维数组实际只是数组的数组，多维数组的元素在内存中实际仍然是以一维的数组的形式存储。对于二维数组，通常把第一个维度称作行，第二个维度称作列。

```cpp
// 根据前面提过的从内向外理解数组的定义，可以看出数组名字是 arr，
// arr是一个含有3个元素的数组，
// 而右边依然是一个数组，则说明arr的每一个元素也是一个数组，
// 这个数组包含了4个元素，每个元素的类型是 int
int arr[3][4]; // 定义多维数组
```

多维数组也可以使用列表初始化，多维数组的初始化的写法建议对每个维度进行分别初始化，即每个维度都使用花括号进行区分，虽然形式上比较复杂，但是更容易理解，也不易出错。

```cpp
int arr1[2][3] = {
    {1,2,3},
    {4,5,6}
};
// 下面的初始化等价于
// {
//  {0,0,0,0},
//  {1,1,1,1},
//  {2,2,2,2},
//  {3,3,3,3}
// }
int arr2[3][4] ={{0},{1},{2},{3}};

// 全部初始化为某个值，例如0
int arr3[4][2] = {0};
```

当使用下标运算符访问多维数组的元素时，数组的每个维度都对应一个下标运算符。**如果表达式含有的下标运算符数量比数组的维度小，那么表达式的结果将是给定索引处的一个内层数组**。

```cpp
int arr[2][3] = {
    {1,2,3},
    {4,5,6}
};
int val = arr[0][1]; // val = 2,表示第一行第第二列位置的元素。
int (&row)[3] = arr[0]; // row是二维数组arr的第一行数组的引用
```

使用范围 _for_ 遍历多维数组时，如果使用 _auto_ 自动推断类型，则需要将变量定义为引用，以防止编译器自动将数组名转换为指向首元素的指针，导致编译错误。

```cpp
int arr[2][3] = {
    {1,2,3},
    {4,5,6}
};

// 注意为引用类型
for(auto &row : arr) {
    for(auro &col : row){
        std::cout << col;
    }
}
```

对于多维数组名，编译转换后的指针实际是指向第一个内层数组的指针。

```cpp
int arr[3][4];
int (*pArr)[4] = arr; // 数组名转换为第一内层数组的指针
pArr = &arr[2]; // 将指针指向第三行的位置

auto pArr2 = arr; // 自动推导，pArr2实际也是指向第一个内层数组的指针
```

在多维数组的使用中，使用类型别名可以很好的简化工作

```cpp
using int_array = int[2][3]; // 等价于 typedef int int_array[2][3]

int_array  arr = {
    {1,2,3},
    {4,5,6}
};
```
