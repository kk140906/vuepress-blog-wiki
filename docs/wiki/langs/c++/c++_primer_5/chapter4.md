---
title: 4. 表达式
order: 4
category:
  - C++
tag:
  - 优先级
  - 运算符
  - 类型转换
article: false
date: 2017-08-27
---

## 4.1 基础

表达式是由一个或多个运算对象组成，对表达式求值将得到一个结果。

### 4.1.1 基本概念

C++ 的运算符有**一元运算符**和**二元运算符**，顾名思义，只需要一个运算对象的运算符为一元运算符，需要两个运算对象的是二元运算符。除此之外，还存在**三元运算符**，如 `operand1 ? operand2 : operand3`。函数调用也是一种特殊的运算符，它对运算对象没有限制。运算符通常要求其运算对象具有相同的类型，但如果运算对象的类型可以转换为同一种类型，那么也可以进行运算。通常，小整数类型(如 _bool_,_char_,_short_) 通常会被提升成较大的整数类型(如 _int_)。

:::tip

C++ 表达式要么是**左值**，要么是**右值**，某些对象既可作作为左值，也可以作为右值。当一个对象被用作右值的时候，用的是对象的值(内容)；当对象被用作左值的时候，用的是对象的身份(在内存中的位置)。

:::

```cpp
// 定义变量i,i此时是一个左值，表示在内存中用一个位置来存储42;
int i = 42;

// 将i的值赋值给j,那么此时i就是一个右值，
// 表示将i所代表位置的内存中的值拷贝到j所代表位置的内存中
int j = i;
```

==当需要右值的地方可以使用左值替代，但是不能把右值当作左值使用==。不同的运算符是否要求其运算对象为左值或其求值结果是否是左值有所区别，下面几个常见的运算符要求其运算对象是左值

- 赋值运算符("=")：赋值运算符的左侧运算对象必须是左值，得到的结果也是一个左值；
- 取地址符("&"): 取地址符的右侧运算对象必须是左值，返回一个指针(`&i`)，而该指针却是一个右值；
- 内置的解引用运算符("\*")及下标运算符("[ ]")：解引用运算符的右侧对象及下面运算符的左侧对象都要求左值，求值结果都是左值；
- 内置类型和迭代器的递增("++")和递减("-\-")运算：无论是前置运算符还是后置运算符都是作用在左值对象上，而前置的运算符的结果是左值；

> 使用关键字 _decltype_ 推断左值和右值也有所区别，如果表达式的结果是一个左值，那么推断将会得到引用。第二章提过，_decltype_ 的运算对象如果是变量将得到变量的类型，变量的 _const_ 及引用特性都会被保留，而如果运算对象是表达式，那么推断的类型是表达式的结果。例如解引用操作的推断 "decltype(\*p)"，解引用操作得到左值，我们不仅得到了指针指向的对象，同时还能修改对象，这就是引用的特性，因此推断的结果是引用类型。又例如取地址操作的推断 "decltype(&p)" ，取地址操作实际得到的是对象 p 的地址，是个右值，因此我们推断的结果就应该得到对象的地址，这符合指针的特性，如果 p 本身是 _int_ 类型，那么 "decltype(&p)" 推断的类型是 _int \*_。
>
> ```cpp
> #include<iostream>
> int main(){
>  std::cout << "hello world" << std::endl;
>  int p;
>  decltype(&p) t;
>  std::cout << typeid(t).name(); // visual studio 输出结果为 int* __ptr64
> }
> ```

### 4.1.2 优先级与结合律

**复合表达式** 是指由两个及其以上运算符组成的表达式，优先级和结合律决定了运算对象组合的方式，优先级的作用高于结合律 ，而括号可以改变运算符的优先级和结合律。下表列出了全部的运算符优先级及其结合律，分组优先级往下依次降低，分组内优先级相等。

:::center

<table border="2">
  <tr>
    <th align="center">结合律</th>
    <th align="center">运算符</th>
    <th>功能</th>
    <th>用法</th>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center"><b>::</b></td>
    <td>
      全局作用域<br />
      类作用域<br />
      命名空间作用域
    </td>
    <td>
      <b>::name</b><br />
      <b>class::name</b><br />
      <b>namespace::name</b>
    </td>
  </tr>
  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center">
      <b>.</b><br />
      <b>-&gt;</b><br />
      <b>[]</b><br />
      <b>()</b><br />
      <b>()</b><br />
    </td>
    <td>
      成员选择<br />
      成员选择<br />
      下标<br />
      函数调用<br />
      类型构造<br />
    </td>
    <td>
      <b>obj.member</b><br />
      <b>pointer-&gt;member</b><br />
      <b>expr[expr]</b><br />
      <b>func(expr_list)</b><br />
      <b>type(expr_list)</b><br />
    </td>
  </tr>
  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">右</td>
    <td align="center">
      <b>++</b><br />
      <b>--</b><br />
      <b>typeid</b><br />
      <b>typeid</b><br />
      <b>explicit cast</b><br />
    </td>
    <td>
      后置递增<br />
      后置递减<br />
      类型ID<br />
      运行时ID<br />
      类型转换<br />
    </td>
    <td>
      <b>lvalue++</b><br />
      <b>lvalue--</b><br />
      <b>typeid(type)</b><br />
      <b>typeid(expr)</b><br />
      <b>cast_name&lt;type&gt;(expr)</b><br />
    </td>
  </tr>
  <tr>
    <td colspan="4"></td>
  </tr>
   <tr>
    <td align="center">右</td>
    <td align="center">
      <b>++</b><br />
      <b>--</b><br />
      <b>~</b><br />
      <b>!</b><br />
      <b>-</b><br />
      <b>+</b><br />
      <b>*</b><br />
      <b>&amp;</b><br />
      <b>()</b><br />
      <b>sizeof</b><br />
      <b>sizeof</b><br />
      <b>sizeof...</b><br />
      <b>new</b><br />
      <b>new[]</b><br />
      <b>delete</b><br />
      <b>delete[]</b><br />
      <b>noexcept</b><br />
    </td>
    <td>
      前置递增<br />
      前置递减<br />
      位求反<br />
      逻辑非<br />
      一元负号<br />
      一元正号<br />
      解引用<br />
      取地址<br />
      类型转换<br />
      对象的大小<br />
      类型的大小<br />
      参数包的大小<br />
      创建对象<br />
      创建数组<br />
      释放对象<br />
      释放数组<br />
      能否抛出异常<br />
    </td>
    <td>
      <b>++lvalue</b><br />
      <b>--lvalue</b><br />
      <b>~expr</b><br />
      <b>!expr</b><br />
      <b>-expr</b><br />
      <b>+expr</b><br />
      <b>*expr</b><br />
      <b>&amp;lvalue</b><br />
      <b>(type)expr</b><br />
      <b>sizeof expr</b><br />
      <b>sizeof(expr)</b><br />
      <b>sizeof...(name)</b><br />
      <b>new type</b><br />
      <b>new type[size]</b><br />
      <b>delete expr</b><br />
      <b>delete[] expr</b><br />
      <b>noexcept(expr)</b><br />
    </td>
  </tr>
  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center">
      <b>-&gt;*</b><br />
      <b>.*</b><br />
    </td>
    <td>
      指向成员选择的指针<br />
      指向成员选择的指针<br />
    </td>
    <td>
      <b>ptr-&gt;*ptr_to_member</b><br />
      <b>obj.*prt_to_member</b><br />
    </td>
  </tr>
  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center">
      <b>*</b><br />
      <b>/</b><br />
      <b>%</b><br />
    </td>
    <td>
      乘法<br />
      除法<br />
      取模(取余)<br />
    </td>
    <td>
      <b>expr1 \* expr2</b><br />
      <b>expr1 / expr2</b><br />
      <b>expr1 % expr2</b><br />
    </td>
  </tr>
  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center">
      <b>+</b><br />
      <b>-</b><br />
    </td>
    <td>
      加法<br />
      减法<br />
    </td>
    <td>
      <b>expr1 + expr2</b><br />
      <b>expr1 - expr2</b><br />
    </td>
  </tr>
  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center">
      <b>&lt;&lt;</b><br />
      <b>&gt;&gt;</b><br />
    </td>
    <td>
      左移<br />
      右移<br />
    </td>
    <td>
      <b>expr1 &lt;&lt; expr2</b><br />
      <b>expr1 &gt;&gt; expr2</b><br />
    </td>
  </tr>
  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center">
      <b>&lt;</b><br />
      <b>&lt;=</b><br />
      <b>&gt;</b><br />
      <b>&gt;=</b><br />
    </td>
    <td>
      小于<br />
      小于等于<br />
      大于<br />
      大于等于<br />
    </td>
    <td>
      <b>expr1 &lt; expr2</b><br />
      <b>expr1 &lt;= expr2</b><br />
      <b>expr1 &gt; expr2</b><br />
      <b>expr1 &gt;= expr2</b><br />
    </td>
  </tr>
  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center">
      <b>==</b><br />
      <b>!=</b><br />
    </td>
    <td>
      相等<br />
      不相等<br />
    </td>
    <td>
      <b>expr1 == expr2</b><br />
      <b>expr1 != expr2</b><br />
    </td>
  </tr>
  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center">
      <b>&amp;</b><br />
    </td>
    <td>
      位与<br />
    </td>
    <td>
      <b>expr1 &amp; expr2</b><br />
    </td>
  </tr>
  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center">
      <b>^</b><br />
    </td>
    <td>
      位异或<br />
    </td>
    <td>
      <b>expr1 ^ expr2</b><br />
    </td>
  </tr>
    <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center">
      <b>|</b><br />
    </td>
    <td>
      位或<br />
    </td>
    <td>
      <b>expr1 | expr2</b><br />
    </td>
  </tr>
   <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center">
      <b>&amp;&amp;</b><br />
    </td>
    <td>
      逻辑与<br />
    </td>
    <td>
      <b>expr1 &amp;&amp; expr2</b><br />
    </td>
  </tr>  
  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center">
      <b>||</b><br />
    </td>
    <td>
     逻辑或<br />
    </td>
    <td>
      <b>expr1 || expr2</b><br />
    </td>
  </tr>  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">右</td>
    <td align="center">
      <b>? :</b><br />
    </td>
    <td>
      条件判断<br />
    </td>
    <td>
      <b>expr1 ? expr2 : expr3</b><br />
    </td>
  </tr>
   <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">右</td>
    <td align="center">
      <b>=</b><br />
    </td>
    <td>
      赋值<br />
    </td>
    <td>
      <b>lvalue = expr2</b><br />
    </td>
  </tr>  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">右</td>
    <td align="center">
      <b>*=,/=,%=</b><br />
      <b>+=,-=</b><br />
      <b>&lt;&lt;=,&gt;&gt;=</b><br />
      <b>&amp;=,|=,^=</b><br />
    </td>
    <td>
      复合赋值<br />
    </td>
    <td>
      <b>expr1 += expr2</b><br />
    </td>
  </tr>  
  <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">右</td>
    <td align="center">
      <b>throw</b><br />
    </td>
    <td>
      抛出异常<br />
    </td>
    <td>
      <b>throw expr</b><br />
    </td>
  </tr>
    <tr>
    <td colspan="4"></td>
  </tr>
  <tr>
    <td align="center">左</td>
    <td align="center">
      <b>,</b><br />
    </td>
    <td>
      逗号运算符<br />
    </td>
    <td>
      <b>expr1 , expr2</b><br />
    </td>
  </tr>
</table>

:::

### 4.1.3 求值顺序

优先级决定了运算对象的组合方式，但是没有明确规定运算对象的求值顺序。例如 `int i = f1() * f2();` "f1" 和 "f2" 两个函数的调用一定会在乘法和赋值运算之前，但是对两个运算对象 "f1" 和 "f2" 相互之间的求值顺序并没有明确说明。只有四个运算符明确规定了运算对象的求值顺序

- 逻辑与运算符(&&)：先对左侧运算对象进行取值，左侧运算结果为真才计算右侧运算对象的值；
- 逻辑或运算符(||)：先对左侧运算对象进行取值，左侧运算结果为真就不会计算右侧运算对象的值；
- 条件运算符(?\:)：先判断第一个表达式，结果为真则最终结果为第二个表达式的值，否则为第三个表达式的值；
- 逗号运算符(,)： 从左向右依次执行，最后一个表达式的值作为结果。

## 4.2 算术运算符

算术运算符主要包含 “+(一元运算符), -(一元运算符), \*, /, %, +(二元运算符), -(二元运算符)”。当一元 + 运算符作用于一个指针或者算术值，返回运算对象的一个副本或者返回类型提升后的副本；一元的 - 运算符会对运算对象取负后返回其副本或者返回类型提升后的副本。

```cpp
int i = 42;
int j = -i; // j=-42
int *p = &i;
// p的值是i的地址，是一个正整数数值，因此可以使用+运算符
std::cout << +p << std::endl;
bool b = true;
bool b1 = -b; // b的值是1，取负后是-1，-1转换成布尔值仍然为true;
```

:::warning

算术表达式可能产生未定义的结果：例如除数为 0，或者计算溢出。<b>溢出的行为是未定义的</b>，有的是发生“环绕( <i>Wrapped around</i> )”,例如 short 的范围是-32768 ~ +32767，如果值为 32767，那么加 1 后的结果变为了-32768。

:::

在进行算术运行时，需要注意下面几点：

1. 整数相除的结果仍然为整数，例如 `int val = 21 / 6;` 该表达式的结果是 3；
2. C++ 11 规定，在除法运算中，商一律向 0 取整，直接丢弃小数部分 <Badge text="C++11" type="info" />；
3. 取余操作的两个运算对象必须为整数；
4. 根据取余运算的定义，如果 m 和 n 都是整数，且 n 为非 0,那么除了 -m 导致溢出的特殊情况，其他任何时候 $(-m) / n$ 和 $m/(-n)$ 都等于 $-(m/n)$，$m\%(-n)$ 等于 $m\%n$，$(-m)\%n$ 等于 $-(m\%n)$。

## 4.3 逻辑和关系运算符

逻辑运算符可以作用于任意能够转换成 _bool_ 类型的运算对象，逻辑运算符主要包含 " !、&lt;、<=、&gt;、>=、==、!=、&amp;&amp;、||"。

逻辑与运算符和逻辑或运算符对求值顺序有要求，必须先对左侧对象求值，然后再对右侧对象求值。

- **&&:** 当左侧对象的结果是 _true_ 才会对右侧对象进行求值；
- **||:** 当左侧对象的结果是 _false_ 才会对右侧对象进行求值。

逻辑非运算符将运算对象的值取负后返回。关系运算符比较运算对象的大小，并返回 _bool_ 类型，因此将关系运算符连写在一起会造成理解错误。例如 "a < b < c" ，这个表达式的结果就会被转换成 c > 0 或者 c > 1 的结果。

## 4.4 赋值运算符

赋值运算符的左侧运算对象必须是一个可修改的左值，其运算结果是它的左侧运算对象，并且是一个左值，因此，如果右侧运算对象的类型与左侧运算对象的类型不同，那么就会将结果转换为左侧运算对象的类型。

==C++ 11 允许使用花括号初始化列表作为赋值运算的右侧运算对象<Badge text="C++11" type="info" />，如果左值运算对象是内置类型，那么初始值列表最多只能含有一个值，如果初始化列表的值可以转换为左侧运算对象，那么初始化列表中数值的空间不能大于左侧运算对象的空间。==

```cpp
int i = 42;
// 这是允许的
i = 3.14;
// 这是不允许的，因为3.14是double类型，占据空间比int类型大
i = {3.14}
```

C++ 提供复合赋值运算符，如 “+=，-=，<<="等，无论哪个复合赋值运算符，其都等价于 _a = a op b_。

由于 C++ 允许在条件语句中进行赋值，那么就需要注意不要混淆 = 和 ==

## 4.5 递增和递减运算符

递增和递减运算符是对运算对象执行加 1 和减 1 的操作，可作用于数值、指针、迭代器等。递增和递减分均包含前置和后置两个版本，==后置版本优先级高于前置版本==：

- 前置版本：先对运算对象执行加 1 和减 1 操作，然后返回运算对象的左值引用；
- 后置版本：先拷贝运算对象，然后执行加 1 和减 1 操作，返回运算对象的拷贝；

除非必须，建议不要使用后置版本。此外使用递增和递减运算符还需要注意运算对象的求值顺序。

```cpp
// 错误的用法，赋值运算符左右两端的对象都用到了beg
// 右侧运算对象还改变了beg的值，该行为未定义
// 编译器可能先处理右侧运算对象，也可能先处理左侧运算对象
while(beg != s.end()){
    *beg = toupper(*beg++);
}
```

## 4.6 成员访问运算符

点运算符和箭头运算符都可用于访问成员，箭头运算符作用于一个指针类型的运算对象，那么结果是一个左值 。点运算符分成两种情况：

- 如果成员类型是左值，那么结果也是左值；
- 如果成员类型是右值，那么结果也是右值。

对指针对象使用点运算符需要注意，点运算符优先级高于解引用，因此需要使用括号进行处理，如 `(*p).size()`。

## 4.7 条件运算符

条件运算符允许我们将简单的 "if - else" 的逻辑嵌入到单个表达式中，条件运算符按照如下形式使用：

```cpp
// 先判断条件cond是否为true,
// 如果为true，那么条件运算符的结果是expr1，否则为expr2
// 其中expr1和expr2是要求类型相同或者都可以转换为某个公共类型
cond ? expr1 : expr2;
```

当条件运算符的两个表达式都是左值或者都能转换成同一种左值类型时，运算的结果是左值，否则，运算结果是右值。

条件运算符允许嵌套，满足右结合律，意味着靠右边的条件运算符构成了靠左边的条件运算符的第二个表达式。

```cpp
finalgrade = (grade > 90) ? "high pass" : (grade < 60) ? "fail" : "pass";
```

由于条件运算符优先级相对较低，在使用流输出表达式中需要添加括号以保证逻辑的正确性，例如`std::cout << ((grade < 60) ? "fail" : "pass");`

## 4.8 位运算符

位运算符是作用于**整数类型**的运算对象，并把运算对象看作二进制位的集合。位运算符包含 “~, <<, >>, &, ^, |”。通常，如果两个运算对象的类型不同，那么小整型的运算对象会被提升到较大的整型。运算对象可以是带符号或者不带符号，如果为负值，那么位运算符如何处理依赖于机器，而且左移的运算可能改变符号位。因此，==强烈建议仅将位运算符应用与无符号的整数类型==。

移位运算符是令左侧运算对象的内容按照右侧运算要求的移动指定位数。例如 `1 << 5;` 表示将 1 左移 5 位，结果为 32。对于移位运算符其具备以下特性：

1. 返回值为左侧运算对象 (可能发生整型提升) 的拷贝；
2. 右侧运算对象不能为负，且值必须严格小于结果的位数，否则就是未定义的行为；
3. 移位操作如果超出了类型的边界，那么移除边界之外的值被直接舍弃掉；
4. 左移运算符在后面插入数值 0；
5. 右移运算符在前面插入什么数值依赖于左侧运算对象的类型：
   - 如果左侧运算对象是无符号类型，那么则插入数值 0；
   - 如果左侧运算对象是带符号类型，那么在则插入符号位的拷贝或者数字 0，具体是环境而定；
6. 移位运算符满足左结合性，优先级低于算术运算符，但是高于关系比较运算符、赋值运算符及条件运算符等。

位求反运算符将运算对象逐位求反后生成一个新的值返回。注意，位求反操作会首先将对象进行类型提升，提升时原来的位保持不变，其他为添加数值 0，然后再求反。

**位与运算符**： 两个位数值都是 1，结果为 1，否则为 0；

**位或运算符**： 两个位数值都是 0，结果为 0，否则为 1；

**位异或运算符**： 两个位数值相同，结果为 0，否则为 1；

位与、位或、位异或的返回值并不是 _bool_ 类型的数值，例如 5 & (1UL << 2) 的返回结果是 4，位运算符同样支持复合赋值运算符，例如 “<<=, &=, |=, ^=”等。

## 4.9 sizeof 运算符

_sizeof_ 运算符返回一条表达式或者一个类型名字所占据的**字节数**。_sizeof_ 运算符满足右结合性，返回值为 _size_t_ 类型的**常量表达式**。有两种使用方式：

```cpp
// 使用方法
sizeof (type);
sizeof expr; // 返回的是expr结果类型的大小


// 应用示例
int i = 42;
int *pi = &i;
sizeof(int); //  int的大小，4个字节
sizeof pi; // 指针的大小，32位4个字节，64位8个字节

// 由于sizeof并不会实际求表达式的值，
// 因此对于未初始化的指针进行解引用操作也是正确
sizeof *pi; // int的大小，通常4个字节
```

在 C++ 11 以后，允许使用作用域运算符来获取类成员的大小 <Badge text="C++11" type="info" />。通常情况下，我们只能通过类的对象访问类的成员，但是 _sizeof_ 运算符不会实际求解表达式，因此允许不通过具体的对象获取成员大小。

_sizeof_ 运算符的结果部分地依赖其作用的类型：

- _char_ 类型或者类型为 _char_ 的表达式，结果为 1；
- 引用类型实际是获取引用对象的大小；
- 指针得到的是指针本身所占据的大小；
- 解引用指针得到指针所指向的对象类型的大小；
- 数组得到整个数组所占据的空间，不会将数组转换成指针进行处理；
- 对 _string_ 或 _vector_ 对象只会返回该类型固定部分的大小，不会计算对象中元素占用了多少空间。

## 4.10 逗号运算符

逗号运算符含有两个操作对象，规定了其求值顺序，按照从左向右的顺序依次求值，逗号运算符的结果为最后一个表达式的求值结果，如果最后一个表达式的结果是左值，那么最终的结果也是左值。

## 4.11 类型转换

在 C++ 中，如果两个对象可以相互转换，那么而它们就是有关联的。在运算中，C++ 并不会直接对两个不同类型的运算对象进行运算操作，而是先尝试进行隐式转换，然后再运算。转换的过程是尽可能避免损失精度的，因此较低的对象类型会被提升为较高的较高类型。而在初始化赋值过程中，由于左侧运算对象的类型无法更改，因此只能将右侧对象转换为左侧对象。

```c++
// 3.14是double类型，3是int类型
// 加法运算之前，3会被提升为double类型，计算结果为double类型
// i是int类型左值，无法更改类型,
// 因此初始化赋值操作会将double类型转换为int类型
int i = 3.14 + 3;
```

下面几种情况，编译器会自动隐式转换类型：

1. 大多数表达中，比 _int_ 类型小的整型会首先被提升为较大的整数类型；
2. 在条件中，非 _bool_ 类型转换为 _bool_ 类型；
3. 在初始化和赋值中，右侧对象转换为左侧对象；
4. 多种类型的算术运算或者关系运算，转换成同一种类型；
5. 函数调用时发生的转换，例如数组的首地址转换为指针等。

### 4.11.1 算术转换

对于不同类型的运算对象总是转换成最宽的类型，例如一个运算对象为 _long double_ 类型，那么无论另一运算对象是什么，结果都将转换为 _long double_ 类型。

整型提升是将小整型提升为大整型，通常，比 _int_ 类型小的整型会首先提升为 _int_ 类型，如果 _int_ 类型无法保存所有值，那么则提升为 _unsigned int_ 类型。对于较大的 _char_ 类型( _wchar_t_、_char16_t_、_char32_t_)等将会被转换为 _int_、_unsigned int_、_long_、_unsigned long_、_long long_、_unsigned long long_ 中能够容纳所有值的最小的类型。

对于无符号类型的运算对象，按照以下方式处理：

1. 首先进行整型提升，如果结果类型匹配，那么无须转换；否则，进行转换；
2. 如果提升后的都是带符号类型或者都是无符号类型，则直接按照较大的类型转换；
3. 如果提升后的一个是带符号类型，另一个是无符号类型：
   - 如果无符号类型 >=带符号类型，那么将带符号类型转换为无符号类型；
   - 如果无符号类型<带符号类型，那么转换结果依赖于机器。通常，如果无符号的值都能够保存到带符号中，那么则转换为带符号的类型，否则则将带符号的转换为无符号的类型。

### 4.11.2 其他隐式转换

存在下面几种常见的隐式转换：

1. **数组转换为指针**：很多情况下，数组名会自动转换为指向数组首元素的指针，但是当作为 _decltype_ 的参数、取地址符、_sizeof_ 及 _typeid_ 等运算符时不会发生转换；
2. **指针的转换**：
   - 整数常量值 0 或者字面值指针 _nullptr_ 能力转换成任意类型的指针；
   - 指向任意非常量的指针都能转换成 _void \*_;
   - 指向任意对象的指针能够转换成 _const void \*_；
   - 指向派生类对象的指针向指向基类对象的指针转换。
3. **布尔类型转换**：指针或者算术类型的值为 0 则转换结果为 _false_ ,否则是 _ture_；
4. **常量转换**：允许将非常量的指针或者引用转换为常量的指针或者引用，反向转换则是不允许的；
5. **类类型定义了转换**：重载了类型转换运算符的类可以自动进行类型转换，但是每次只能转换一次。

### 4.11.3 显式转换

显示转换属于强制类型转换，强制类型转换的使用方式是：cast_name&lt;type&gt;(expr)，其中 type 是要转换的最终目标类型，expr 表示要转换的对象，cast_name 表示要进行转换的类型名称，分为 **static_cast**、**dynamic_cast**、**const_cast**、**reinterpret_cast**。

==**static_cast** ：适用于任何具有明确定义，且不包含底层 _const_ 的对象。**static_cast** 的本质是类型的转换，同时用于告诉编译器用户承担损失精度的风险，消除警告，并且也用于处理编译器无法自动转换的类型，例如从 _void \*_ 类型中转换为其存储的值。==

==**const_cast** ：只能用于改变对象的底层 _const_，其根本操作是改变对象的常量属性，而且是改变常量属性的唯一操作，但是该操作不能用于改变对象的类型。==

将常量对象转换为非常量对象通常称为 "去掉 _const_ 性质" (_cast away the const_)。需要注意的是，如果我们去掉了对象的 _const_ 性质，那么编译器就允许对该对象进行写操作，但是写操作是否合法取决于对象自身。

- 如果对象是常量，那么使用 **const_cast** 后对其进行写操作的行为是未定义的；
- 如果对象不是常量，那么使用 **const_cast** 后对其进行写操作是合法的。

```cpp
/**
 * const限定了不能通过该对象修改内存中的值
 * 顶层const针对所有类型，而底层const只针对指针和引用类型
 * 这就意味着顶层const表示对象本身不能修改，
 * 如const int i = 42; i = 50;则是不允许的操作
 * 而底层const表示通过这个对象不能修改所指向或者所引用对象的值
 * const_cast不会处理顶层const，换言之，它会忽略顶层const
 */
string s("hello world");
// 底层const：
const string *ps1 = &s;
// 不能通过指针修改所指向对象的值
// *ps1 = "one";
// 可以修改指向的对象
ps1 = new string("today");

// 顶层const
string * const ps2 = &s;
// 可以通过指针修改所指向对象的值
*ps2 = "two";
// 不能修改指向的对象
// ps2 = new string("today");


// 去掉const特性
// ps1是const string *,含有底层const，转换后ps3是string *
auto ps3 = const_cast<string *>(ps1);
*ps3 = "three"; // 由于ps1是含有底层const的常量，该操作未定义
// ps2是string * const,含有顶层const，转换后ps4是tring *
auto ps4 = const_cast<string *>(ps2);
*ps4 = "four"; // ps2是顶层const，合法

// 添加const特性
// ps2是string * const,含有顶层const，由于const_cast忽略顶层const，转换后ps5是const string *
auto ps5 = const_cast<const string *>(ps2);
ps5 = ps4; // ps5可以修改指向的对象，但是通过ps5修改指向对象的值
// ps4是string * ,由于const_cast忽略顶层const，因此转换后ps6是const string *
auto ps6 = const_cast<const string * const>(ps4);
ps6 = ps3; // 可以修改指向的对象
// *ps6 = "six" // 不能修改指向的对象的值
```

:::note

const_cast 不会处理顶层 const，换言之，它会忽略顶层 const。
:::

==**reinterpret_cast:**  从位模式上重新解释对象类型。用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个比特复制的操作。==

```cpp
int i = 10;
int *pi = &i;
// pi指向的内存中的值仍然为int类型
char *pc = reinterpret_cast<char *>(pi);
*pc = 'a';
std::cout << i << std::endl; // i的值被改为字符'a'的ascii码值97
```

:::danger

reinterpre_cast 本质上依赖于机器，建议不要轻易使用。

在早期的 C++ 版本中，显式类型转换方式为 _type (expr)_ 和 _(type) expr_ ，推荐使用新版本的写法。

:::
