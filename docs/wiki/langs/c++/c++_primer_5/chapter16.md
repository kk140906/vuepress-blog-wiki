---
title: 16. 模板与泛型编程
order: 16
category:
  - C++
tag:
  - 函数模板
  - 类模板
  - 模板特例化
  - 可变参数模板
article: false
date: 2017-09-28
---

## 16.1 定义模板

### 16.1.1 函数模板

> 模板是 C++中泛型编程的基础，泛型编程的两个重要原则：
>
> - 模板中的函数参数是 _const_ 的引用，保证了函数可以用于不能拷贝或者常对象类型
> - 函数体中的条件判断仅适用<比较运算

具有通用函数功能的模板称为 "**函数模板**",用来生成特定类型的函数版本。模板定义是以关键字 _template_ 开始，后跟一个 "**模板参数列表**"，列表内是用逗号分隔的一个或多个 "**模板参数**"，模板参数列表不能为空。定义形式：

`template <typename T>`

模板参数列表与函数参数列表类似，使用模板时，我们显式地或者隐式地指定模板实参，并将其绑定到模板参数上。

调用一个函数模板时，编译器利用函数实参推断模板实参，然后利用推断的模板实参去实例化一个特定版本的函数。

定义模板的时候还会指定模板的 "**类型参数**"，类型参数与内置类型及自定义的类型说明符一样，如 _int_ 等。特别地，==每一个模板的类型参数前必须使用关键字 _class_ 或者 _typename_。==

```cpp
// T1和T2是类型参数，表示一种类型
template <typename T1,typename T2>
func(const T1&,const T2&);
```

除了可以定义类型参数外，模板还能定义 "**非类型的模板参数**"，非类型的模板参数表示的是一个值，而不是一个类型，==在非类型的模板参数前面添加的应该就是类型，而不是关键字 _class_ 或者 _typename_==。非类型的模板参数类型具有以下几种类型：

- 整型：要求实参必须是常量表达式
- 指向一个对象或者函数类型的指针或引用：要求实参必须是具有静态的生存期，指针参数也可以用 _nullptr_ 或者一个值为 0 的常量表达式来实例化

当一个非类型的模板参数被实例化的时候，非类型的参数被一个用户提供的或者编译器推断出的值所代替，而==**这些值必须是常量表达式。**==

```cpp
template<unsigned N,unsigned M>
int compare(const char (&p1)[N],const char (&p2)[M]) { return strcmp(p1,p2); }

// 调用时,编译器会使用字面常量的大小来代替N和M，从而实例化模板，
// 由于编译器会在一个字符串常量的末尾添加一个空字符作为结尾，因此编译器实例的版本等价为：
// int compare(const char (&p1)[6],const char (&p2)[6])
compare("hello","world")
```

函数模板也可以声明为 _inline_ 或者 _constexpr_ 的，声明的关键字放在模板参数列表之后，返回值类型之前

```cpp
// 正确的书写方式
template <typename T>
inline T min(const T&,const T&);
```

编译器遇到模板定义时，并不生成代码，只有当我们使用模板时才会生成代码。这一特性会影响代码的组织形式及错误的检测机制。

通常，但我们调用一个函数，编译器只需要知道函数的声明即可，当使用一个类类型的对象时，类必须是可定义的，但是类的成员函数不比定义，因此可以将类的定义和函数声明放在头文件，而普通函数和类的成员函数放在源文件中

**<u>==模板则不同，为了生成一个实例化的版本，编译器需要掌握函数模板或类模板成员函数的定义，因此与非模板代码不同，模板的头文件通常既包括声明也包括定义。==</u>**

模板的编译错误通常在实例化期间报告的，主要分为三个阶段

1. 编译模板本身时，编译器可以检查语法错误，如忘记分号或者变量名写错等
2. 编译器遇到模板使用时
   - 函数模板的调用，编译器会检查实参的数目，参数类型是否匹配
   - 类模板的调用，编译器会用户提供的检查模板实参的数目
3. 模板实例化时，这时候编译器才能发现类型相关的错误，但是可能在链接的时候才会报告出来

### 16.1.2 类模板

"**类模板**" 是用来生成类的蓝图的，与函数模板不同的是编译器不能为类模板推断模板参数的类型。

类似函数模板，类模板也以关键字 _template_ 开始，后跟模板参数列表。在类模板的定义中，使用模板参数代替使用模板时需要提供的类型或值。

```cpp
template<typename T>
class Blob{
  using ValuesType = T;
private:
  ValuesType element_;
  std::vector<T> v_container_;
};
```

与函数模板可以隐式指定模板实参不同的时，我们使用类模板时必须==显式指定模板实参列表==，例如`vector<int>`，_int_ 就是显式指定的模板实参，而调用函数模板如 `compare("hello","world")` 就是隐式指定的实参。

当编译器为类模板实例化出一个模板类时，会重写模板，将类中所有使用模板参数的地方替换为给定的模板实参。

==**一个类模板的每个实例都形成一个独立的类，相互之间没有任何的关系。**==

如果一个类模板中的代码使用了另外一个模板，那么通常将类模板的模板参数用作另外一个模板的实参。例如 Blob 类模板中的 v_container\_成员。

类模板中的成员函数与普通成员函数类似，但是每个类模板的实例都有自己版本的成员函数。**默认情况下一个类模板的成员函数只有当程序用到它时才进行实例化，否则，它不会被实例化。**

处于类模板外部的定义需要在定义前添加相应模板的声明，而处于类模板内部的声明或定义则可以忽略模板参数。

```cpp
template <typename T>
class Blob {
public:
  // 类模板作用域内部可以不添加模板参数
  Blob();

  void print(const T& content);
}

// 类模板外部定义构造函数
// 首先进行模板的声明,然后正常定义类构造函数，注意定义类构造函数时必须使用类模板的作用域Blob<T>::Blob
template <typename T>
Blob<T>::Blob(){}

// 类模板外部定义print成员函数的方式,
// 首先进行模板的声明,然后正常定义类成员函数，注意定义类成员函数时必须使用类模板的作用域
template <typename T>
void Blob<T>::print(const T& content){
  std::cout << content << std::endl;
}

```

**类模板与友元的关系比较复杂，简单总结如下：**

- _class_ 为类模板:
  - 友元为类模板:
    1. 友元声明为所有类模板，那么该友元的所有实例都是类模板所有实例的友元
    2. 友元声明为特定其他类模板，那么该友元的实例是类模板所有实例的友元
    3. 友元声明为当前类模板，那么类模板会生成与之实例一一匹配的友元
  - 友元为非类模板，那么该友元则是所有类模板实例的友元
- _class_ 为非类模板：
  - 友元为类模板：
    1. 友元声明为所有类模板，那么该友元的所有实例都是当前类的友元
    2. 友元声明为特定其他类模板，那么该友元的实例是当前类的友元
  - 友元为非类模板，那么该友元与当前类呈唯一对应关系

**在 C++11 标准中，友元的类型可以是模板类型参数或者内置类型。如果要在类模板外定义友元比较复杂，模板的编写最好在声明的同时就定义，省去诸多不必要的麻烦。**

```cpp
/*
 * class为类模板
 */
// 前置声明类模板和函数模板
template <typename> class Blob;
template <typename F_> Blob<F_> operator+(Blob<F_> &lhs,Blob<F_> &rhs);

template <typename T>
class Blob {
  // BlobPtr友元类模板的所有实例都是Blob类模板的每一个实例的友元
  template <typename T> friend class BlobPtr;
  // 用int实例化的BlobPtr类模板是Blob类模板的每一个实例的友元
  friend class BlobPtr<int>;
  // 友元模板为当前类模板，根据类型参数生成一一匹配的友元,注意两个关键点
  // 1.必须前置声明友元函数模板及类模板
  // 2.友元定义声明时必须使用当前类的模板形参作为友元函数的模板实参,即下面声明中的<T>
  friend Blob operator+<T>(Blob &lhs,Blob &rhs);

  // Test为非类模板友元，该友元是Blob类模板的每一个实例的友元
  friend class Test;

  // 声明类型参数T作为Blob类模板的友元，C++ 11后允许
  friend T;
}
// 类外定义
template <typename F_> Blob<F_> operator+(Blob<F_> &lhs,Blob<F_> &rhs){}

/*
 * class为普通类
 */
class Blob {
  // BlobPtr友元类模板的所有实例都是Blob类的友元
  template <typename T> friend class BlobPtr;
  // 用int实例化的BlobPtr类模板是Blob类的友元
  friend class BlobPtr<int>;

  // Test为非类模板友元，该友元是Blob类的友元
  friend class Test;

  // 声明内置float作为Blob类的友元，C++ 11后允许
  friend float;
}

```

_typedef_ 可以定义实例化以后的类模板的别名，但是不能直接定义类模板的别名，C++11 以后可以使用 _using_ 定义类模板的别名。

```cpp
// 正确
typedef Blob<int> IntBlob;
// 错误
typedef Blob<T> TBlob;
// 使用using定义类型别名
template <typename T> using BlobTemplate = Blob<T>;
BlobTemplate<int> int_blob_;
```

类模板中的 _static_ 成员与普通类的 _static_ 成员类似，但是类模板的每一个实例都会生成自己版本的 _static_ 成员，然后同一个实例的不同对象共享同一个 _static_ 成员。

### 16.1.3 模板参数

模板参数与变量类似，也遵循变量的作用域规则，模板参数会隐藏在其外层作用域中的同名变量名，但是在模板内部不能够重新定义模板参数名。

```cpp
typedef double A;
template <typename A ,typename B>
void f(A a,B b){
  // 正确，A的类型是模板参数类型，而不是double
  A tmp = a;
  // 错误，不能对模板内的模板参数进行重定义
  double B;
}
```

通常，使用作用域运算符可以访问类的 _static_ 成员及类的类型成员，默认情况下，通过作用域运算符访问的名字并不是类型。那么对于类模板而言，如果想访问类模板定义的变量必须实例化，但是某些情况下，为了处理模板，编译器必须知道作用域访问的是 _static_ 成员还是类型成员，要解决这个问题可以使用 _typename_ 关键字,一旦类模板实例化出模板类以后就可以直接使用类型了，而不需要再使用 _typename_ 进行说明。

```cpp
template <typename T>
class Blob{
public:
  // 假设需要访问模板参数T的size_type类型，
  // 但是直接使用T::size_type编译器会默认按照模板参数的static成员查找，
  // 如果T内部没有size_type的static成员则会报错，
  // 为解决这个问题可以使用typename进行声明,告诉编译器作用域访问的实际是类型成员
  typename T::size_type size(T &t){
      return t.size();
  }
};
```

函数模板和类模板都可以定义默认实参，限制与普通函数的默认实参一致。无论何时使用一个类模板，我们都必须在模板名之后接上尖括号，即使类模板中都有默认的实参。尖括号标识出类是从一个类模板实例化而来的。

### 16.1.4 成员模板

一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数，这种成员函数称之为“成员模板”，==成员模板是函数模板，并且不能是虚函数。==

普通类的成员模板与函数模板类似，但是类模板的成员模板在类外定义时必须先声明类模板的参数列表，然后声明函数模板参数列表

```cpp
template <typename T>
template <typename It>
Blob<T>::Blob(It b,It e) {}
```

### 16.1.5 控制实例化

模板使用时才会被实例化，这就意味着相同的实例可能出现在多个对象文件中，那么每个文件就会存在该模板的一个实例，在多个文件中实例化相同的模板的额外开销可能非常大，在 C++11 标准后可以通过使用关键字 _extern_ 来声明“显式实例化”解决。由于模板使用时就会被实例化，因此 _extern_ 声明的模板只能用在最后一个相同模板的定义之前。

```cpp
// 显式实例化使用extern关键字进行声明，后面必须明确指明模板实参
extern template class Blob<string>;
```

模板在使用时才会被实例化，这对函数模板是非常适用的，但是对于类模板，实例化会定义该类模板的所有成员，这是因为编译器遇到一个实例化定义时，它并不了解程序使用了哪些成员函数。

### 16.1.6 效率与灵活性

_shared_ptr_ 与 _unique_ptr_ 之间明显的不同是他们管理所保存的指针策略的不同：

- **_shared_ptr_**：允许共享指针所有权的能力
- **_unique_ptr_**：独占指针

_shared_ptr_ 与 _unique_ptr_ 之间另一个不同是允许用户重载默认删除器的方式

- **_shared_ptr_**：较为容器的重载一个智能指针的删除器，在创建或者 "reset" 时都可以更改其删除器
- **_unique_ptr_**：只能在定义的时候显式的指定模板实参以提供其删除器的类型

通常类模板一旦实例化出一个类后，那么其成员的类型应该是固定不变的，而 _shared_ptr_ 却可以任意更改其删除器的类型，因此其将删除器不是类模板的成员，通常删除器保存为一个指针或者封装了指针的类。而 _unique_ptr_ 则是在定义时显式声明的，因此其删除器是类模板的成员。

_unique_ptr_ 在编译时绑定删除器，避免了调用删除器的运行开销，_shared_ptr_ 在运行时绑定删除器，使用户重载更为方便。

## 16.2 模板实参推断

### 16.2.1 类型转换与模板类型参数

编译器从函数实参推断出模板实参的过程称之为 "**模板实参推断**"，模板实参推断过程中，编译器会用这些模板实参生成的函数版本与给定的函数之间进行最佳匹配的函数调用。

**如果模板参数是类型参数，当应用于函数形参时仅会发生以下两种转换**：

- _const_ 转换：可以将一个非 _const_ 对象的引用或者指针传递给一个 _const_ 引用或者指针形参
- 数组或函数指针转换：如果函数形参不是引用类型，那么可以将数组或函数类型的实参应用正常的指针转换。

```cpp
template<typename T> T fobj(T,T); // 实参被拷贝
template<typename T> T fref(const T&,const T&); // 引用

std::string s1("hello");
const std::string s2("hello")
// 拷贝的时候const属性可以被忽略,调用fobj(std::string,std::string)
fobj(s1,s2)
// const转换,调用fref(const std::string &,const std::string &)
fref(s1,s2)
```

由于上面类型转换的限制，函数形参如果使用相同的模板类型参数，则必须要求函数的形参类型相同，期望使用不同类型的函数形参则最好使用多个类型模板参数，而正常的非模板参数的形参则根据普通函数的转换规则进行转换

### 16.2.2 函数模板显式实参

在某些情况下，编译器无法推断出模板实参的类型，例如函数的返回值类型与形参类型均不一致的情况。因此需要显示指定实参列表。显式指定实参列表与定义类模板实例的方式相同，在函数名后使用尖括号进行指定，尖括号内必须指定所有的模板实参，除非位于右侧的模板参数均能通过传递给函数的实参进行推导才能省略指定后面的模板实参。

```cpp
template<typename T1,typename T2, typename T3>
T1 sum(T2,T3);
// T1 显示指定为double，T2和T3通过函数实参推导
auto result = sum<double>(2,3)
```

对于普通类型定义的函数参数，实参可以进行正常的类型转换，因此为了与普通类型定义的函数参数一致，如果模板类型参数的实参由显式指定，那么模板实参也可以进行正常的类型转换

```cpp
template<typename T>
bool compare (const T &,const T &){}

long l = 565656;
// 显式指定模板实参为int类型，因此long类型的实参l被转换为int类型
compare<int>(l,1024);
// 显式指定模板实参为long类型，因此1024被转换为long类型
compare<long>(l,1024);
```

### 16.2.3 尾置返回类型与类型转换

通常，希望用户指定模板参数的类型时，使用显式模板实参相对有效，但是在某些情况下，显式指定模板实参存在一定困难。例如编写了一个函数模板，接受一个序列的迭代器类型，然后返回迭代器指向的元素，由于是函数模板，序列的元素类型可能不同，因此确认函数的返回值就比较困难了。为了解决这个问题，可以采用尾置返回类型的方式。

```cpp
// 定义存放两个不同类型的容器
std::vector<int> vi{1,2,3};
std::vector<std::string> vs{"hello","world"};

// 定义函数模板
// 在这个函数模板中，返回值类型应该是*beg的类型，但是*beg可能是不同类型的元素
// 而编译器在遇到函数的参数列表前，beg并不存在，
// 因此要定义这个函数模板的返回值只能使用尾置返回类型
// 然后利用decltype进行返回值类型推导,
// 解引用运算符返回左值类型，因此推导出的返回值类型应该是左值引用
template<typename It_>
auto show(It_ beg) -> decltype(*beg){ return *beg;}

std::cout << show(vi.begin()) << std::endl;
std::cout << show(vs.begin()) << std::endl;
```

有时我们无法直接获得所需的类型，可以使用标准库定义在 _type_traits_ 头文件中的“类型转换模板”，对目标进行类型转换从而获取到相应的类型。例如对一个左值引用对象 _int &_ 进行 "remove<span>\_</span>reference" 操作可以获取引用对象的原始类型 _int_，标准库类似的类型转换模板主要有以下几个：

:::center

| 类型转换模板 - Mod&ltT&gt;    | 类型转换对象-若 T 为                      | 类型转换结果-Mod&lt;T&gt;::type |
| :---------------------------- | :---------------------------------------- | :------------------------------ |
| remove_referece&lt;T&gt;      | X&amp; 或者 X&amp;&amp; <br>否则          | X <br> T                        |
| add_const&lt;T&gt;            | X&amp; 或者 const X&amp;或者函数 <br>否则 | T <br> const T                  |
| add_lvalue_reference&lt;T&gt; | X&amp; <br/> X&amp;&amp; <br>否则         | T <br> X&amp; <br/> T&amp;      |
| add_rvalue_reference&lt;T&gt; | X&amp; 或者 X&amp;&amp; <br>否则          | T <br> T&amp;&amp;              |
| remove_pointer&lt;T&gt;       | X&lowast; <br>否则                        | X <br> T                        |
| add_pointer&lt;T&gt;          | X&amp; 或者 X&amp;&amp; <br>否则          | X&lowast; <br> T&lowast;        |
| make_signed&lt;T&gt;          | unsigned X <br>否则                       | X <br> T                        |
| make_unsigned&lt;T&gt;        | 符号类型 <br>否则                         | unsigned X; <br> T              |
| remove_extent&lt;T&gt;        | X[n] <br>否则                             | X <br> T                        |
| remove_all_extents&lt;T&gt;   | X[n1][n2]... <br>否则                     | X <br> T                        |

:::

利用类型转换模板、尾置返回及 _decltype_ 等手段可以在函数中返回别的类型

```cpp
// 返回迭代器所指向的对象的一个拷贝，而不是左值引用
template<typename It>
auto fcn2(It beg) -> typename remove_reference<decltype(*beg)>::type {
  return *beg;
}
```

### 16.2.4 函数指针和实参推断

当使用一个函数模板去初始化函数指针或者赋值时，编译器会使用函数指针的类型去推断模板实参。

```cpp
// 声明一个函数模板，
template<typename T>
int compare(const T&,const T&);


// 定义一个函数指针,然后使用函数模板去初始化它
// 编译器会使用func_的类型去推断函数模板的实参，根据别名FuncP_Int，推断出T的实参类型为int
// 如果不能推断出来唯一对应的模板实参，那么就会产生错误
using FuncP_Int = int(*)(const int&,const int&);
FuncP_Int func_int = compare;

// 例如有一个重载的函数，接受不同版本的函数指针
void f(FuncP);
using FuncP_Str = int(*)(const std::string&,const std::string&);
void f(FucP_Str);
// 在调用时使用函数模板就会错误，因为编译器推断出的模板实参类型可能为int或者std::string
f(compare);
```

### 16.2.5 模板实参推断和引用

对于函数调用进行的模板实参推断，编译器会应用正常的绑定规则。此外，_const_ 是底层的，这意味着绑定的对象的值不能被更改。

```cpp
// 针对这个函数模板，T是类型模板参数，在函数声明中，接受的参数类型是T类型的左值引用
// 那么在进行函数实参推断的过程中，
// 推断的结果应该是T类型，而不是T类型的引用，引用与函数形参绑定在一起
template<typename T>
void func(T &p);
```

**函数参数是左值引用类型**:

函数的模板参数是普通的左值引用类型(形如:_T&_)，那么只能传递给它一个左值，如果实参类型是 _const_ 类型的，那么推断的模板实参类型也是 _const_ 的。

函数的模板参数是 _const_ 的左值引用类型(形如: _const T&_),那么可以传递给它任何类型的实参(一个 _const_ /非 _const_ 对象，一个临时对象，或者是一个字面值常量)。切记函数模板的形参中的 _const_ 是函数的一部分，不是模板形参的一部分，因此推断出来的模板实参类型不会是 _const_ 类型。

```cpp
int i;
const int j = 42;

template<typename T>
void func1(T&);
func1(i); // i是int类型的左值，推断的T类型为int
func1(j); // j是int类型的常量，推断的T类型为const int
func1(5); // 错误，常量5是右值，不能将一个普通的左值引用绑定到一个右值上

template<typename T>
void func2(const T&);
func1(i); // i是int类型的左值，推断的T类型为int
func1(j); // j是int类型的常量，推断的T类型为const int
func1(5); // 正确，可以将一个常量绑定到const int类型的左值上
```

**函数参数是右值引用类型：**

函数的模板参数是右值引用类型(形如:_T&&_)，那么正确的绑定规则告诉我们可以传递给它一个右值。

通常情况下，如果我们将一个左值传递给函数形参，那么根据右值引用不能绑定到左值上的规定，显然这样的函数调用是不合法的。但是 C++语言在这种正常的绑定规则之外定义两个例外的规则，这两个规则是标准库 "move" 操作的工作基础：

- 如果将一个 "**左值**" 作为函数实参传递给 "**函数模板参数的右值引用(如: _T&&_)**" 时，编译器推断的模板实参的类型是函数实参的左值引用
- 对于间接创建的引用的引用，除了右值引用的右值引用会折叠成右值引用外， 其他所有引用的引用都会折叠会左值引用

> 回顾一下，引用不是一个对象，无法直接定义引用的引用，但是如果使用了类型别名或者模板参数或者间接绑定，那么可以间接创建引用的引用。
>
> ```cpp
> // 无法直接定义引用的引用
> // int j = 0;
> // int &&r = &j;
> // 类型别名间接创建引用的引用
> using RInt = int &;
> using RRInt = RInt &;
> // 定义变量i,ri是i的左值引用，而rri是ri的左值引用，这从表面上就间接创建了引用的引用
> // 本质原因是引用也是一个变量，是一个左值，因此可以继续绑定到新的引用上
> int i = 5;
> RInt ri = &i;
> RRInt rri = &ri;
> ```
>
> ==引用的引用会被折叠： **X&** &，**X&** &&, **X&&** &都会被折叠成 “**X&**”;只有 **X&&** &&才会被折叠成 “**X&&**”。==

```cpp
// 函数参数类型为模板参数类型的右值引用
template<typename T>
void func(T &&);
// 5是一个右值，那么根据引用绑定的正常规则，推断的T类型为int
func(5);
int i = 42;
// i是左值，根据引用的特殊绑定规则，推断的T类型为int &,
// 编译器推断的结果可能形式为 void func<int &>(int & &&),
// 根据折叠规则，函数的实际声明应该为 void func<int &>(int &),因此这个调用也是合法的。
func(i);

```

> 这两个特殊的规则导致了两个重要的结果：
>
> 1. 如果函数参数是一个==指向模板类型参数的右值引用(形如：T&&)==，那么它可以被绑定到一个左值
> 2. 如果函数实参是一个左值，那么==推断的模板实参类型是一个左值引用==，并且函数的参数将会被实例化(折叠)为一个普通的左值引用
>
> 这就暗示着，可以将任意类型的实参传递给 T&&类型的函数参数。

针对上述推断的模板实参类型可能是一个左值引用会对代码造成一些影响。例如

```cpp
template<typename T>
void func(T && value){
  // 如果传递给value的值是一个左值，那么推断的T的类型将是左值的引用，
  // 下面这个语句就等价于定义一个左值引用t，将t绑定到value上;
  // 而如果传递给value的值是一个右值，那么推断的T的类型就是该右值的对象类型
  // 下面这个语句就等价于定义一个新的变量t，然后利用value的值对其进行初始化
  T t = value;
}
```

:::tip

为了避免上述情况，右值引用通常仅用于两种情况：一个是对模板实参的转发；另一个是对模板的重载。

:::

### 16.2.6 理解 std::move

```cpp
// 标准库的std::move定义
template<typename _Tp>
constexpr typename std::remove_reference<_Tp>::type&&
move(_Tp&& __t) noexcept {
   return static_cast<typename std::remove_reference<_Tp>::type&&>(__t);
}
```

- 对于 "std::move" 函数，其函数参数为指向模板类型参数的右值引用，可以接受所有参数
- 通过 "remove_reference" 类型转换模板可以获取到对象的非引用类型，如果函数实参为右值，那么推断的模板实参类型就是对象非引用类型，"remove_reference" 什么也不做，函数形参就是右值引用类型；如果函数实参为左值，那么推断的模板实参为对象的左值引用，"remove_reference" 会移除其左值引用，函数形参由于折叠特性会被实例化对象的左值引用
- 如果函数形参就是右值引用类型，那么 _static_cast_ 什么也不做，直接返回右值引用；而如果函数形参是左值引用类型，那么 _static_cast_ 将显式转换左值引用为右值引用，然后返回右值引用。

> 通常情况下, _static_cast_ 只用于其他合法的类型转换，虽然不能隐式的将左值转换为右值引用，但是对于右值引用，可以使用 _static_cast_ 显式地将一个左值转换为右值引用。

### 16.2.7 转发

所谓转发是在某些情况下需要将函数的一个或者多个实参连同类型不变地的转发给其他函数。在这种情况下，需要保持被转发实参的所有性质，包括实参类型是否是 _const_ 类型或者是否是左值引用或者右值引用。

根据模板实参的推断和引用的规则，可以清楚的知道要想保持转发实参的所有性质，只能在函数形参定义其类型为指向模板类型参数的右值引用，这样如果函数参数是左值，那么推断的模板实参类型为非引用对象类型的左值引用，而函数的形参类型则根据折叠规则实例为非引用对象类型的左值引用，如果是右值，那么推断的模板实参类型为非引用对象自身的类型，而函数的形参类型则保持其右值引用类型。

```cpp
void print(int &, int){}
// 定义一个函数模板,进行参数转发，arg1和arg2类型均为指向模板类型参数的右值引用
template<typename F_, typename T1, typename T2>
void flip1(F_ func, T1 && arg1, T2 && arg2){
  func(arg1,arg2);
}

int i = 42;
// i是左值，5是右值
// 根据模板实参推断规则，T1的类型为int &，而T2的类型为int
// 而arg1的类型会根据折叠规则实例化为int &，arg2的类型仍然保持为int &&
// 当在flip1函数内部进行参数转发的时候，arg1的左值引用与print的第一个形参完全匹配
// 而arg2会被拷贝初始化print的第二个形参
flip1(print,i,5);
```

根据上面这个实例可以看出，在函数模板内部转发时，可调用对象的实参是函数模板的形参，而函数模板的形参却是是个局部变量，这是个左值，如果可调用对象接受的参数是右值引用类型，那么引用绑定规则告诉我们不能将一个右值引用绑定到一个左值上，因此上面的实例调用就会错误。

为了解决这个问题，C++11 标准库引用了 "std::forward" 函数模板，"std::forward' 必须通过显式模板实参来调用，==它返回显式模板实参类型的右值引用(即 "std::forward&lt;T&gt;" 的返回类型为 _T&&_)==，同时根据折叠规则，它将能保持原始实参类型的左值或者右值属性。换言之，如果实参类型是左值引用，那么左值引用的右值引用将被折叠成左值引用；而如果实参类型为右值引用，那么右值引用的右值引用将被折叠成右值引用。

```cpp
void print(int &, int &&){}
// 定义一个函数模板,进行参数转发，arg1和arg2类型均为指向模板类型参数的右值引用
template<typename F_, typename T1, typename T2>
void flip1(F_ func, T1 && arg1, T2 && arg2){
  func(std::forward<T1>(arg1),std::forward<T2>(arg2));
}

int i = 42;
// i是左值，5是右值
// 根据模板实参推断规则，T1的类型为int &，而T2的类型为int
// 而arg1的类型会根据折叠规则实例化为int &，arg2的类型仍然保持为int &&
// 当在flip1函数内部进行参数转发的时候，
// std::forward返回T1的右值引用，形如T1 & &&，这会被折叠为T1 &
// std::forward返回T2的右值引用，形如T2 &&，
flip1(print,i,5);
```

## 16.3 重载与模板

函数模板可以被另外一个模板或者一个普通的非模板函数重载，对于函数模板，函数匹配规则会有以下影响：

1. 对于一个函数，其候选函数包括所有可行的模板实参推断实例
2. 可行的函数按照类型转换来排序
3. 如果一个函数只有一个比其他任何函数更好的匹配，那么就选择这个函数，而如果一个函数有多个同样好的匹配，那么匹配规则(编译器总是优选选择更特例化的匹配函数)为：
   - 如果同样好的函数中只有一个非模板函数，则选择该非模板函数
   - 如果同样好的函数中没有非模板函数，而有多个函数模板，但是其中某个函数模板比其他都更加特例化，则选择特例化的函数模板
   - 否则，此调用具有二义性。

> 在定义任何函数模板前，记得声明所有重载的函数版本，这样就不必要担心编译器由于未遇到你希望的调用的函数而实例化一个并非你需要的版本。

## 16.4 可变参数模板

==接受可变数目参数的函数模板或者模板类称之为 "**可变参数模板**"，可变数目的参数被称之为“参数包”==，参数包有两种类型：

- **模板参数包**：表示 0 个或者多个模板参数,在 _typename_ 后面添加 "**…**" 表示模板参数包
- **函数参数包**：表示 0 个或者多个函数参数，在类型名后面添加 "**…**" 表示函数参数包

与往常一样，编译器从函数的实参推断模板参数类型，对于一个可变参数模板，编译器还会推断包中参数数目。

为了知道包中含有多少个参数可以使用 _sizeof…_ 运算符，它返回一个常量表达式，而且不会对实参求值。

```cpp
// typename后的...告诉编译器该模板是一个可变参数的模板，Args表示一个模板参数包
// 函数形参中类型名后的...告诉编译该函数包含可变函数参数包，args表示一个函数参数包
template<typename T1, typename... Args>
void func(const T1 & t1, const Args &... args);
// 计算模板参数包中的参数数目
std::cout << sizeof...(Args) << std::endl;
// 计算函数参数包中的参数数目
std::cout << sizeof...(args) << std::endl;
```

### 16.4.1 编写可变参数函数模板

对于不知道实参的数目及类型时采用可变参数函数模板是比较好的方式。可变参数函数模板通常都是递归的，第一步调用处理包中的第一个实参，然后用剩余实参调用自身。同时，为了终止递归，还需要定义一个非可变参数的函数。当递归终止时，可变参数模板推断的函数与非可变参数的函数都能被正确匹配，但是由于非可变的参数的函数更加特例化，编译器会选择非可变参数的函数版本。

```cpp
// 递归终止的非可变参数的函数模板
template<typename T>
std::ostream & print(std::ostream &os,const T & t){
  return os << t;
}

// 可变参数的函数模板
template<typename T,typename... Args>
std::ostream & print(std::ostream &os,const T & t,const Args &... args){
  // 先处理第一参数
  os << t << ", ";
  // 然后递归调用处理后续剩余的参数，args...是剩余的参数包
  print(os,args...);
}
```

### 16.4.2 包扩展

对一个参数包，除了获取其大小外，唯一能操作的就是扩展(展开)包。对一个包的扩展实际是将一个包分解为构成包的元素，然后将每一个模式应用到每个包的元素上，最终获得扩展后的列表。==在模式的后面放一个省略号("**…**" )可以触发扩展操作。==例如 `print(os,args…)`中 args 后面的 "**…**"，其中 args 是模式。

> 包扩展的时候，会将模式独立的应用到包中的每一个元素上。

### 16.4.3 转发参数包

C++11 标准后，可以组合使用可变参数模板与 "std::forward" 机制来将实参不变的传递给其他函数。要实现类型信息的转发通常需要两个阶段过程：

1. 为了保持实参中的类型信息，必须将函数参数定义为模板类型参数的右值引用
2. 当在函数模板的函数体内部转发参数时必须使用 "std::forward" 保持实参的原始类型。

```cpp
// fun的形参类型为可变参数模板类型参数的右值引用，可以接受任意类型的实参
// std::forward传递实参，保证了所有的类型信息都会被保持
template<typename... Args>
void fun(Args &&... args){
  // 做实际工作的函数，work调用的实参的扩展既扩展了模板参数包Args，也扩展了函数参数args
  work(std::forward<Args>(args)...)
}
```

## 16.5 模板特例化

在某些情况下，通用模板的定义对特定类型是不适合的，因此可以为通用模板定义一个特例化版本。==**一个特例化版本就是模板的一个独立的定义，在其中的一个或者多个模板参数被指定为特定版本。注意，特例化只是模板的一个实例，并不是重载了一个模板。**==

**函数模板的特例化：**

对于函数模板的特例化，必须为原模板中的每个模板参数都提供实参。在关键字 _template_ 后面跟一个空的尖括号对`<>`，以指出我们将为原模板的所有模板参数提供实参。

```cpp
template<>
bool compare(const char *const &lhs,const char *const &rhs){}
```

为了特例化一个模板，源模板的声明必须在作用域中，而且在任何使用了模板实例的代码之前，特例化版本的声明也必须在作用域中，通常，将模板及其特例化版本应该声明在同一头文件中，所有的同名模板的声明应该放在前面，而特例化的版本则放在后面。

**类模板的特例化：**

与函数模板不同，类模板的特例化不必为所有模板参数提供实参。即可以对类模板进行部分特例化，也称为模板的偏特化。而一个类模板的部分特例化本身也是一个模板，使用时用户还必须为哪些在特例化版本中未指出的模板参数提供实参。类模板的偏特化有两种类型，一种是具有默认模板类型参数的偏特化，另一种是限定模板类型参数为某种特定的类型。

```cpp
template<typename T> struct remove_reference{ typedef T type;};
// 类模板部分特例化版本，在类模板后面用尖括号显式指定了模板参数类型
template<typename T> struct remove_reference<T&>{ typedef T type;};
template<typename T> struct remove_reference<T&&>{ typedef T type;};
```

类模板成员的特例化

```cpp
template<typename T> struct Foo{
    void Bar(){}
};
// 特例化类模板的成员
template<>
void Foo<int>::Bar(){}
```
