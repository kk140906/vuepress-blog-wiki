---
title: 15. 面向对象程序设计
order: 15
category:
  - C++
tag:
  - 类
  - 虚函数
  - 抽象基类
  - 访问控制
  - 继承
article: false
date: 2017-09-26
---

## 15.1 OOP：概述

> 很多程序中都存在一些相互关联但是又存在细微差别的概念，例如，书店的不同书籍的定价策略可能不同，有的书籍按照原价销售，有的则打折销售。有时候我们给哪些购买书籍超过一点数量的顾客打折，另一些时候，则只对前多少销售的书籍打折，之后就调回原价，等等。

OOP 的核心思想是数据抽象(封装)，继承和动态绑定(多态)。

- 数据抽象(封装)：对事物的属性进行抽象，然后将数据和操作集中描述，并添加不同的访问权限
- 继承：可以定义相似的类型并对其相似关系建模
- 动态绑定(多态)：可以在一定程度忽略相似类型的区别，用统一的方式使用他们的对象

通过继承联系在一起的类可以构成一种层次关系，通常在层次关系的根部有一个基类(_base class_)，其他类则直接或间接从基类继承而来，这些继承得到的类称为派生类(_derived class_)。**==<u>基类赋值定义在层次关系中所有类共同拥有的成员，而每个派生类定义个各自特有的成员。所有类的私有成员仅对自己可见(声明为友元除外。)，即使是派生类拥有基类的成员也不能直接访问基类的私有成员。</u>==**

_对某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就需要把这类函数声明成虚函数。_

使用基类的引用或者指针调用一个虚函数时将会发生动态绑定。这就意味着如果是普通类型对象调用虚函数时，将在编译时就能够确定需要使用的版本，不会发生动态绑定。

派生类是通过类派生列表明确指出它是从哪些基类继承而来的。

```cpp
class Quote{
public:
  std::string isbn() const;
  // 虚函数
  virtual double net_price(std::size_t n) const;
  virtual ~Quote();
};
// 公有继承
class Bulk_quote : public Quote {
public:
  // 派生类重写基类的方法
  double net_price(std::size_t n) const override;
};
```

:::tip

继承的本质揭示了派生类与基类之间的关系。派生类是基类的一个扩展(“ is-a ”关系)，这就意味着，可以将派生类的对象当做基类去使用，因为派生类包含了基类的所有成员，因此可将基类的指针或者引用绑定到派生类对象的基类部分上(换言之，在需要基类指针或者引用的地方，可以使用派生类的对象进行绑定)。但是不能将基类的对象当成派生类对象去使用，因为基类不包含派生类的所有成员。

:::

## 15.2 定义基类与派生类

> 基类通常都应该定义一个虚析构函数。

基类必须将两种成员函数区分开：

- 一种是基类希望其派生类进行覆盖的函数，基类通过声明 _virtual_ 使得函数成为虚函数，可以被动态绑定；派生类通过声明 _override_ 重写基类函数。
- 另一种是基类希望其派生类不要改变，直接继承的函数。

成员函数如果没有被声明为虚函数，则其解析过程发生在编译时期。

派生类是通过类派生列表明确指出它是从哪些基类继承而来的。类派生列表的书写形式为：

`class 派生类名 : 继承方式(public,protected,private) 基类名 { 派生类成员 };`

继承方式限定了从基类继承而来的成员是否对派生类外部的用户是否可见。

派生类通常会重写从基类继承的虚函数，如果派生类不重写基类中继承的某个虚函数，那么派生类会直接继承在基类中的虚函数版本。

C++ 标准库没有规定派生类的对象在内存中如何分布的，但是可以认为派生类的对象包含两个部分：

- 从基类继承而来的成员
- 派生类自定义的成员

<u>由于继承的特性，派生类对象中包含基类的所有成员，所以我们能把派生类对象当成基类对象使用，同样的，也就能把派生类对象绑定到基类的指针或者引用上。</u>

```cpp
// 基类对象
Quote item;
// 派生类对象
Bulk_quote bulk;
// 定义基类指针，指向基类对象
Quote *p = &item;
// 基类指针，指向派生类中的基类部分
p = &bulk;
// 定义基类引用，绑定到派生类中的基类部分
Quote &r = bulk;
```

每个类控制它自己的成员进行初始化过程，派生类中含有从基类继承的成员，但是它也不能直接初始化这些从基类继承的成员，因此在派生类的初始化过程中，会首先调用基类的构造函数完成基类成员的初始化，然后调用派生类的构造函数完成派生类成员的初始化。

派生类的构造函数同样是通过构造函数初始化列表将实参传递给基类的构造函数的，默认情况下派生类的对象的基类部分会像数据成员一样执行默认初始化，如果希望使用基类的其他构造函数，那么则需要在派生类的构造函数初始化列表中以基类名加圆括号类的实参列表的形式为基类的构造函数提供初始值。

```cpp
Bulk_quote::Bulk_quote(const std::string& book,
  double price,
  std::size_t quntity,double discount) :
  Quote(book,price),
  min_quntity(quntity),
  discount(discount) {}

```

如果基类中定义了静态的成员，那么这个静态成员仅存在一个定义，如果基类的静态成员属性是 _private_，那么派生类就不能使用。

派生类的声明与普通类的声明形式一致，不能在声明中声明继承的基类。

作为基类的类必须是完整定义的类，这样派生类才能知道应该继承哪些成员。继承的基类根据继承层次分为直接基类和间接基类。

在 C++11 中为了防止某个类作为基类，可以在类名之后添加 _final_ <Badge text="C++11" type="info" /> 关键字进行限定，_final_ 限定后别的类就不能作为它的派生类。

```cpp
class Base{};
// Base是D1的直接基类
class D1 : public Base {};
// Base是D2的间接基类
class D2 : public D1 {};

// final关键字限定D3不能作为基类被继承
class D3 final : public Base{};
// 错误使用:
class D4 : public D3{};
```

**类型转换与继承：**

通常情况下，定义对象的引用或指针的类型必须与对象一致，或者存在一个可接受的 _const_ 转换。但是对于包含继承关系的类是个例外，由于派生类中包含所有的基类成员，所以我们可以把基类的引用绑定到派生类对象上，指针(智能指针)也具有同样的性质。这就意味着当我们使用基类的指针或者引用时并不清楚的知道绑定或者指向的是派生类对象还是基类对象。

- 静态类型：类型在编译时已知，是变量在声明时的类型或者表达式生成的类型
- 动态类型：运行时才知，是变量或者表达式在内存中的对象类型

> 基类的指针或者引用的静态类型可能与其动态类型不一致。这是因为由于继承的关系，基类的指针或者引用可能指向或者绑定到派生类对象的基类部分。

从派生类到基类的转换实际包含了一个隐式转换的过程(**==这个转换实际是类类型转换，转换仅对指针和引用有效==**)，但是从基类到派生类就不存隐式转换，因为基类不包含派生类的某些成员。由于编译器只能通过静态类型来推断操作是否合法，同时由于存在派生类到基类的隐式转换，因此一个派生类向一个基类的转换是合法的；而基类到派生类不存在隐式转换，因此是非法的，但是可以使用 _static_cast_ 强制覆盖编译的类型检查。

```cpp
class Base{};
// Base是D1的直接基类
class D1 : public Base {};

D1 d1;
// 合法，派生类隐式转换为基类
Base *pBase = &d1;
// 不合法，基类向派生类转换不存在隐式转换
D1 *pD1 = pBase;
//  合法，显式转换基类为派生类
D1 *pD2 = static_cast<D1 *>(pBase);
```

在派生类和基类之间没有重载类类型转换运算符，这就意味着如果将派生类对象转换为基类对象实际调用的是基类的拷贝/移动构造函数或者拷贝/移动赋值运算符实现(**==换言之，派生类对象与基类对象之间不存在类类型转换==**)。

```cpp
class Base{};
// Base是D1的直接基类
class D1 : public Base {};

D1 d1;
// 调用基类的拷贝构造函数，拷贝派生类对象d1的基类部分去初始化b1
Base b1(d1);
// 调用基类的拷贝赋值运算符
b1 = d1;
```

当使用派生类对象初始化基类对象时，只有派生类对象中的基类部分被拷贝、移动或者赋值，其他部分被忽略掉。
派生类的对象只能初始化它的直接基类，这就意味着如果一个派生类存在间接基类，那么间接基类将是通过直接基类进行初始化的，如此层层初始化，直至最顶层的基类被初始化。

## 15.3 虚函数

_对某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就需要把这类函数声明成虚函数。_

通常情况下，如果某些不需要使用的函数可以只声明而不定义，但是声明为虚函数的成员函数必须要实现定义，这是因为虚函数通常是用于动态绑定的，编译器并不知道应该使用哪个函数，因此必须都定义。

如果基类中某个成员函数被声明为虚函数，那么在它的所有的派生类中都是虚函数。

派生类可以重写基类的虚函数，但是在派生类的返回值类型，形参类型必须与基类保持一致。即 **基类与派生类的 "调用形式" 必须一致**。如果在派生类中定义了一个与基类中虚函数名字相同的函数，但是形参列表不同，那么则认为派生类中的函数是新的函数，不是重写的基类的虚函数。为了解决这个问题，**在 C++11 以后可以使用 _override_ <Badge text="C++11" type="info" /> 关键字声明该函数重写了基类的虚函数，此时编译器会检测在派生类中重写的虚函数的调用形式与基类中某个虚函数的调用形式是否一致。** 但是对于返回值为基类指针的虚函数，派生类中虚函数的返回值可以是派生类的指针，只要派生类能够隐式转换为基类。

与限制类被继承类似的，我们也可以在函数后面指定 _final_ 关键字，以限制该函数不被任何方式重写 _final_ 和 _override_ 限定符出现在形参列表(包括 _const_、引用限定符、尾置返回类型)之后。函数后的 _final_ 声明了函数不能再被重写了，这就暗示了对于派生类中的虚函数我们已经有了最终的实现(重写)，就没必要使用 _override_ 去告诉编译器该函数是被重写的函数。

如果虚函数使用了默认实参，那么在派生类中重写的虚函数的默认实参仍然与基类中的定义的默认实参一致。通常禁止在虚函数中使用默认实参，需要默认实参的场合采用函数重载进行替换。

在某些情况下，例如派生类中重写的虚函数需要调用基类中被重写的那个虚函数时，希望对虚函数的调用不进行动态绑定，可以通过作用域运算符强制限定调用的虚函数版本。如果不使用作用域限定符("`::`")，那么在运行时该调用将由于动态绑定特性被解析为对派生类版本的递归调用。

## 15.4 抽象基类

如果类中某个函数没有实际意义，而且又期望继承它的派生类实现自己的版本，那么我们可以将这个函数定义为 "**==纯虚函数==**"，定义`=0`的虚函数是纯虚函数，纯虚函数不需要定义，如果需要定义，只能在类的外部进行定义。

含有(或者未被重写直接继承)纯虚函数的的类是 "**==抽象基类(纯虚类)==**"，抽象基类负责定义接口，其派生类负责实现接口。我们不能直接创建一个抽象基类的对象。

## 15.5 访问控制与继承

每个类分别控制自己的成员初始化过程，与之相似，每个类还分别控制着其成员对于派生类来说是否<u>**可访问**</u>。

**类中成员的访问限定：**

1. **共有属性**：无论成员的访问限定是什么属性，<u>类的内部成员</u>都能直接访问
2. **共有属性**：友元不具备传递性及继承性，友元声明之后只能对<u>当前类的内部成员(如果友元声明的类属于基类，那么所谓的内部成员也包括派生类中的基类部分的成员)</u>有效。
3. 声明为 **_public_** 的成员能被<u>类的对象</u>直接访问，也能被<u>派生类的内部成员</u>及<u>派生类对象</u>直接访问
4. 声明为 **_protected_** 的成员不能被<u>类的对象</u>直接访问，也不能被<u>派生类对象</u>直接访问，但是可以被<u>友元</u>及<u>派生类的内部成员</u>访问，如果派生类中声明了一个友元，那么这个友元也满足第 2 条特性，如果恰好基类中又存有 _protected_ 的成员，那么通过这个友元可以访问继承自基类的 _protected_ 成员。这是因为友元能够访问派生类的所有内部成员，而基类的 _protected_ 成员又能够被派生类的内部成员访问。
5. 声明为 **_private_** 的成员不能被<u>类的对象</u>、<u>派生类的内部成员</u>及<u>派生类对象</u>直接访问，但是可以被<u>友元</u>直接访问

> 声明为 protected 的成员不能被<u>派生类对象</u>访问，本质原因是派生类无论采用什么方式继承基类，基类的被保护的成员在派生类中要么是私有成员，要么是被保护的成员，这些属性对<u>派生类外部对象</u>而言都是派生类私有的。

**继承关系中的访问限定：**

继承关系中的访问限定是控制派生的用户(包括派生类对象，派生类的派生类，派生类的指针及引用等)对于基类成员的访问限定。

- **_public_**：保留基类中成员原有的访问限定
- **_protected_**：基类中的 _public_ 成员和 _protected_ 成员都变为派生类的 _protected_ 成员
- **_private_**：基类中的 _public_ 成员和 _protected_ 成员都变为派生类的 _private_ 成员

==派生类虽然继承了基类的所有成员，但是却只能访问基类的 _public_ 和 _protected_ 成员。==

在实际使用中，派生类向基类存在转换，那么这个转换是否可访问由以下几个方面确定：

1. 只有派生类的继承方式为 _public_ 时，<u>类的外部用户</u>才能使用派生类向基类的转换
2. <u>派生类的内部成员</u>和<u>友元</u>一定能够使用派生类向基类的转换
3. 只有派生类的继承方式为 _public_ 或者 _protected_ 时，<u>派生类的派生类内部成员</u>和<u>友元</u>_可以使用派生向基类的转换_
   > 基类应该将接口声明为 _public_，将属于实现的部分分为两组：对于派生类的内部成员可访问的声明为 _protected_，对于只能由基类及基类友元访问的成员应该声明为私有的 _private_

有时候我们需要对某一些单独的成员进行继承属性的变更，例如类的继承方式为 _private_,但是我们期望其中某个成员的继承方式为 _public_，针对这种情况可以使用 _using_ 声明进行访问权限的变更。值得注意的是，由于派生类只能够访问基类 _public_ 成员及 _protected_ 成员，那么 _using_ 声明也只能用于这两类成员。

与类的定义具有默认访问限定类似，继承也具有默认的访问限定，该访问限定由<u>定义派生类时的关键字</u>决定，即派生类的关键字是 _struct_ 时默认 _public_，派生类的关键字是 _class_ 时默认 _private_。

## 15.6 继承中的类作用域

每个类定义自己的作用域，如果存在继承关系，那么派生类中包含基类的全部成员，因此当某个成员在派生类中无法正确解析时，编译器会在基类的作用域中查找。

一个对象、引用或指针的静态类型决定了该对象哪些成员是可访问的。

```cpp
struct A{
public:
    int a;
};
struct B: public A{
public:
    int b;
};
struct C: public B{
public:
    int c;
};

C c;
// pb是指向B类的指针，由于作用域限制只能访问A类和B类的成员
B *pb = &c;
// pa是指向A类的指针，由于作用域限制只能访问A类的成员
A *pa = &c;
```

继承中的函数调用解析过程，例如调用`p->mem()(obj.mem())`:

- 首先确定 p(或者 obj)的静态类型，由于调用的是一个成员，那么类型为 class 类型
- 在 p(或者 obj)的静态类型对应的类中查找 mem 成员，如果找不到就在直接基类中查找，直至达到继承链的顶端
- 找到名字后才会进行类型检查，以确认调用的合法性
- 如果合法会检查是否是虚函数，如果是虚函数还会检查当前调用是否是指针或者引用，那么编译器编译的代码是在运行时才确定到底应该运行哪个函数，如果不是虚函数或者调用不是指针或引用，那么编译器编译的代码是常规的函数调用代码。

在派生类定义的与基类相同的成员名称将会隐藏基类的成员，类似于局部变量会隐藏同名的全局变量。如果同名的成员是函数类型，即使派生类的形参列表与基类的形参列表不一致也不会重载基类的函数，而是直接隐藏掉基类的函数。这是因为名字查找优先于类型检查，在派生类的作用域进行名字查找就找到了重名的函数，而调用时类型却不是正确的调用形式，因此编译器会提示错误。

```cpp
struct A{
public:
    void hello(const std::string &info);
};
struct B: public A{
public:
    void hello();
};


B b;
// 错误，b是派生类对象，在派生类中找到了hello，但是该函数没有形参，因此提示错误
b.hello("hi");
```

由于名字查找优先于类型检查，因此必须要求派生类重写的虚函数的调用形式必须与基类的虚函数的调用形式一致。如果基类与派生类的虚函数接受不同的参数，那么派生类中就存在两个同名函数，一个是继承自基类的虚函数，另一个是派生类自己定义的普通函数，那么通过基类的指针或引用就只能访问对基类的对象了。

```cpp
struct A {
  virtual void print() { std::cout << "A" << std::endl; }
};

struct B : public A {
  void print(int i) { std::cout << "B: " << i << std::endl; }
};

B b;
A *pa = &b;
// 派生类与基类的print函数形参不同，查找首先会在基类中查找，
// 在基类中找到print后，编译器识别出是虚函数，而且调用也是指针类型，会在编译时生成动态调用的代码，
// 但是由于派生类中的print函数形参是int类型，因此派生类并没有重写基类的print虚函数，
// 根据动态绑定，在实际调用时调用的是派生类的print虚函数，
// 但是由于派生类中并没有重写基类的print虚函数，因此仍然调用的是基类的print函数
pa->print();
```

_using_ 声明语句指定一个名字而不指定形参列表，所以一条对基类成员函数的 _using_ 声明就可以把该函数的所有重载实例添加到派生类的作用域中。

## 15.7 构造函数和拷贝控制

### 15.7.1 虚析构函数

继承关系中对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。

通常，_delete_ 一个动态分配的类的对象的指针时会执行类的析构函数，如果 _delete_ 的指针指向了继承体系中的某个类型，那么就可能出现指针的静态类型与被删除的对象的动态类型不符合的情况。

```cpp
// p是基类类型的指针，但是指向的对象却是派生类的对象
Base *p = new Derived();
// 那么在析构时，编译器就应该知道它需要执行的是派生类的析构函数
// 为了正确区分执行的是基类与派生类的析构函数，因此需要将基类的析构函数定义为虚函数，即虚析构函数
struct A {
  virtual ~A() { std::cout << "A" << std::endl; }
};

struct B : public A {
  ~B() { std::cout << "B" << std::endl; }
};

// 由于基类A是虚析构函数，当派生类B继承A类时也会继承其虚析构函数，
// 当我们用派生类对象去初始化含有虚函数的基类的指针或者引用时将会发生动态绑定
// 这样编译器就知道在delete时应该调用哪个析构函数了。
// 分析动态分配的过程我们可以知道,new创建派生类对象时会先调用基类的构造函数，然后再调用派生类的构造函数
// 派生类对象实际包含了两部分内容：基类部分及派生类自己的部分,
// 当我们使用派生类对象去初始化基类指针时实际使用的是派生类的基类部分
A *pa = new B();
// 释放pa实际是释放派生类的基类部分，而这部分属于派生类，因此会调用派生类的析构函数释放派生类自己的部分
// 然后才会调用基类的析构函数释放基类的部分
delete pa;

// 如果A的析构函数不是虚析构函数，那么pa的析构函数在编译时就确定为基类的析构函数了
// 使用基类的析构函数去释放派生类的对象是未定义的行为
```

如果基类的析构函数不是虚析构函数，则 _delete_ 一个指向派生类对象的基类指针将产生未定义的行为。虚析构函数会阻止合成的移动操作！

### 15.7.2 合成拷贝控制与继承

通常，每个类控制着自己的成员进行初始化、赋值、销毁等操作。类似的，派生类在执行这些操作的时候还会调用基类的对应操作去执行基类的初始化、赋值、销毁等操作。派生类要调用基类的操作必须保证相应的成员可以被访问，而且不是 _delete_ 的函数。同样地，对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责调用直接基类的析构函数销毁直接基类的成员。

某些情况下基类的定义方式可能导致合成的拷贝控制被定义为 _delete_ 的函数：

1. 基类中默认构造函数、拷贝构造函数、拷贝赋值运算符或者析构函数被定义为 _delete_ 或者不可访问，那么派生类中的对应函数被定义为 _delete_ 的
2. 基类中有一个不可访问的或者被定义为 _delete_ 的析构函数，那么派生类的合成的默认构造函数、拷贝构造函数、移动构造函数将被定义为 _delete_ 的
3. 移动操作永远不会被定义为隐式的 _delete_ 的函数，如果基类的移动操作是不可访问或者被定义为 _delete_ 的，那么派生类的移动操作将被定义为 _delete_ 的

```cpp
struct A{
  A() = default;
  A(const A&) = delete;
};

struct B : public A { }

// 正确，基类A中有默认的构造函数，那么派生类B中就会自动合成默认的构造函数
B b;
// 错误，基类A中的拷贝构造函数被定义为delete，那么派生类中的拷贝构造函数也会被定义为delete
B b1(b);
// 错误，基类A中有拷贝构造函数，不会合成移动构造函数，派生类中相应的操作也被定义为delete,
// 那么就不能移动和拷贝派生类的对象
B b2(std::move(b));
```

### 15.7.3 派生类的拷贝控制成员

如前面所述，每个类控制着自己的成员进行初始化、拷贝、赋值、销毁等操作。但是由于派生类还具有基类的成员，那么还会调用基类的函数去执行相关操作。**==在默认情况下，基类默认构造函数初始化派生类对象的基类部分，如果我们想拷贝、移动派生类的基类部分，则必须在派生类的拷贝、移动构造函数中显式的使用基类的相应操作去拷贝、移动派生类中的基类部分。==**

```cpp
struct A{};
struct B : public A {
  // 显式的调用基类的拷贝构造函数和移动构造函数去初始派生类的基类部分
  B(const B &b) : A(b) {}
  B(B &&b) : A(std::move(b)) {}
}
```

派生类中的基类部分成员由基类的析构函数隐式销毁，派生类自己的成员则由派生类自己的析构函数销毁，因此在派生类的析构函数体中只负责销毁由派生类自己分配的资源。对象销毁的顺序与创建的顺序相反，即先执行派生类的析构函数，然后执行基类的析构函数。

如果要在构造函数或者析构函数中调用虚函数，那么应该调用与构造函数和析构函数类型相同的类的虚函数版本，即基类的构造或析构函数只能调用基类的虚函数版本，派生类的构造或者析构函数只能调用派生类的虚函数版本。这是因为在构造时，基类的部分先被创建，而此时派生类的部分还未进行构造。类似的，在析构时，派生类的部分先被析构，此时派生类的对象已经没有了，基类不能在调用派生类的虚函数了。

### 15.7.4 继承的构造函数

在 C++11 标准中，派生类使用 _using_ 声明能够重用其直接基类定义的构造函数。具体使用方式如下：

```cpp
// 假设
struct A {
  A(const int &i):a(i){}
private:
  int a;
}

// using声明直接重用直接基类的构造函数
struct B : public A {
  // 对于基类的每个构造函数，编译器都在派生类中生成一个与基类构造函数参数列表相同的构造函数
  using A::A;
}

```

> 对于基类的每个构造函数，编译器都在派生类中生成一个与基类构造函数参数列表相同的构造函数,如果派生类含有自己的成员，则这些成员执行默认初始化。

继承的构造函数具有以下特点：

- 和普通的 _using_ 声明不同，继承的构造函数中不管 _using_ 声明出现在哪个访问限定符后面，继承的构造函数的访问限定与直接基类中重用的构造函数的访问限定保持一致。
- _using_ 声明不能指定为 _explicit_ 或者 _constexpr_，如果直接基类的构造函数是 _explicit_ 或者 _constexpr_,那么继承的构造函数也应该有相同的属性
- 如果直接基类中含有默认实参，那么继承的构造函数不会继承默认实参，而是会将构造函数进行拆分，例如直接基类接受两个参数的构造函数，继承的构造函数会拆分成两个构造函数，一个构造函数接受两个形参，不含默认值，一个构造函数接受最左边的一个形参
- 直接基类中含有多个构造函数，基本会被全部继承，除了以下两个例外情况：
  - 派生类定义的构造函数的参数列表与直接基类中的某个构造函数完全相同，那么直接基类中的那个构造函数就不会被继承
  - 默认、拷贝、移动构造函数不会被继承

## 15.8 容器与继承

容器不能存放不同类型的元素，如果期望存储存在继承关系的元素(例如基类对象与派生类对象)时，通常在声明中告诉编译器存储的元素类型是基类的指针(包括智能指针)，而不是实际的对象。

```cpp
std::vector<std::shared_ptr<Base>> basket;
basket.push_back(std::make_shared<Base>());
// std::make_shared<Derived>返回指向派生类对象的智能指针
// 存放到vector中时智能指针被转换为指向基类的智能指针
basket.push_back(std::make_shared<Derived>());
```

利用容器存储继承关系的类需要用户处理动态内存，例如每次 _push_back_ 时将对象转换为智能指针的操作。最好的方式是直接传递对象，而不由用户去进行对象转换，因此可以进行一定封装，这就会用到 "模拟虚拷贝的方式"。

所谓的 "**==模拟虚拷贝==**" 是在基类中定义一个虚函数，拷贝当前基类对象，然后在派生类中重写基类的虚拷贝函数，拷贝当前的派生类对象。这样就在一定程度上封装了用户传递的接口。

```cpp
class Base{
  // 拷贝版本,返回指针是因为容器里面的元素类型是shared_ptr,同时注意动态分配对象
  virtual Base* clone() const & { return new Base(*this); }
  // 移动版本,返回指针是因为容器里面的元素类型是shared_ptr,同时注意动态分配对象
  virtual Base* clone() && { return new Base(std::move(*this)); }
};

class Derived{
  // 拷贝版本,返回指针是因为容器里面的元素类型是shared_ptr,同时注意动态分配对象
  virtual Derived* clone() const & { return new Derived(*this); }
  // 移动版本,返回指针是因为容器里面的元素类型是shared_ptr,同时注意动态分配对象
  virtual Derived* clone() && { return new Derived(std::move(*this)); }
};
```
