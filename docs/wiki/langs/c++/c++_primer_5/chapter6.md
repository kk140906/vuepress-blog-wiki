---
title: 6. 函数
order: 6
category:
  - C++
tag:
  - 函数重载
  - 函数匹配
  - 函数指针
article: false
date: 2017-09-05
---

## 6.1 函数基础

函数定义包含返回类型、函数名、0 个或多个的参数列表以及函数体。其中形参以逗号分隔，位于一对圆括号内部，函数通过调用运算符来执行函数。函数的调用完成下面两项工作：

- 使用实参初始化函数对应的形参；
- 暂时中断主调函数的执行，将控制权转交给被调用的函数。

函数调用第一步会隐式定义并初始化它的形参，在函数执行的过程中遇到一条 _return_ 语句时会结束函数的执行过程，_return_ 语句实际也完成了两个工作：

- 如果函数有返回值，将值返回；
- 将控制权从被调函数中还给主调函数。

在函数调用的过程中，实参被用来初始化形参，因此形参一定会被初始化。实参与形参一一对应，两者类型必须匹配。函数的形参列表可以为空，但是不能被省略。

大部分类型都能作为函数的返回值类型，==**其中数组、函数类型不能用作函数的返回值，但是可以返回指向数组或者函数的指针**==。_void_ 是一种特殊的返回类型，表示函数不返回任何值。

### 6.1.1 局部对象

函数体是一个语句块，块构成一个新的作用域，形参和函数体内部定义的变量称为“局部变量”，仅在函数体内部可见，**局部变量会隐藏在外部作用域的同名变量**。

**自动对象**：指只存在块执行期间的对象，当块执行结束后，块中创建的自动对象就变成了未定义。内置类型的未初始化局部变量将产生未定义的值。

**局部静态对象**：_static_ 关键字可以让变量成为局部静态对象，局部静态对象会让局部变量的声明周期贯穿程序的整个执行周期。局部静态对象在第一次遇到对象的定义语句的时候进行初始化，并且直到程序终止才被销毁。如果局部静态变量没有显式的初始化，那么将执行值初始化，内置类型被初始化为 0。

### 6.1.2 函数声明

函数的名字必须在使用之前进行声明，函数声明也称作函数原型。函数只能定义一次，但可以声明多次。特别地，如果一个函数永远也不会用到，那么可以只声明不定义。

函数声明与函数定义非常类似，唯一区别就是函数声明无需函数体，以分号结尾。由于函数声明不包含函数体，因此就需要函数形参列表中变量定义。

### 6.1.3 分离式编译

分离式编译允许我们把程序分割到几个文件中，每个文件可以单独翻译。每一个源文件都是一个翻译单元，生成可执行程序需要经过预编译、编译、汇编及链接。预编译主要处理以“#” 字符开始的宏定义等，编译主要将源文件翻译成汇编代码，汇编主要将编译的结果生成机器码，而链接则负责将汇编的对象文件链接在一起生成可执行文件。

## 6.2 参数传递

> **形参初始化与变量初始化机理类似。**如果形参是引用类型，那么就意味着将这个引用类型的形参绑定到初始化变量，否则，就将实参的值拷贝之后赋值给形参。

### 6.2.1 传值参数

如果形参类型不是引用，那么实参被拷贝到函数中，因此在函数内部对形参的操作不会影响到实参。

如果形参的类型是指针，那么拷贝的是指针的值，虽然拷贝以后的指针仍然与实参不同，但是都指向同一对象，我们可以通过指针修改指针指向对象的值。

### 6.2.2 传引用参数

如果形参类型是引用，那么则允许在函数内部通过该引用改变引用所绑定对象的值。

对于较大的类类型对象或者容器对象，传值参数会进行拷贝操作，但是拷贝操作消耗较大，甚至很低效，而传递引用参数可以避免拷贝。有的类类型甚至都不支持拷贝操作，例如 IO 类型，因此只能使用传引用参数，如果函数内部无须修改实参的值最好使用常量引用。

使用引用不仅可以避免拷贝操作，而且可以通过引用参数传递函数内部的数据到函数外部。

### 6.2.3 const 形参和实参

如果形参中含有 _const_ 限定，那么需要注意顶层 _const_ 与底层 _const_ ，==顶层 _const_ 作用于对象本身，在初始化时，形参的顶层 _const_ 会被忽略。== 这个特性也暗示了：

- 我们可以使用常量对象或者非常量对象对其进行初始化，形参中的顶层 _const_ 相当于做出了承诺，承诺不改变形参对象的值或者不通过形参对象修改其指向的值。
- 顶层 _const_ 不能作为函数是重载函数的判断依据。

:::warning

<b>尽量使用常量引用</b> ：定义为常量引用具有下面两个好处：

- 定义为普通引用意味着在函数内部可以被修改，这会对函数调用者造成误导，而常量引用可以避免这个问题。
- 定义为普通引用对象意味着它不能接受 _const_ 对象、字面值常量或者需要进行类型转换的对象。

:::

### 6.2.4 数组形参

数组有两个重要性质：

- ==不允许整体拷贝，那么就无法使用值传递==
- ==数组常被转换为指针，作为实参初始化形参时实际使用的是指向数组首元素的指针==

```cpp
// 下面是等价的三种函数声明的形式
void func1(const int *);
void func2(const int []);
void func3(const int [10]);
```

数组是通过指针形式传递到函数内部，在函数内部并不确切知道数组大小，通过下面三种方式可以进行管理数组：

- 带有标记的数组，例如 C 风格字符串的结尾是 '\0'；
- 使用标准库的迭代器，传递数组的首元素和尾后元素的指针；
- 显示在函数形参列表中添加一个形参表明数组大小

函数形参中也可以定义数组的引用，此时形参绑定到对应的实参数组上，由于数组大小是数组类型的一部分，因此在形参中需要标注出数组的大小。

对于数组有多维数组，我们也可以传递多维数组给函数形参，不过由于数组作为实参传递给形参实际是数组首元素的指针，那么 ==对于多维数组，实际传递给形参的是指向更低维度的数组的指针，而数组第二维以后的大小都是数组类型的一部分，不能被省略。==

```C++
// 注意arr两次需要括号，否则该定义为引用的数组，是错误的
// 注意给出所引用的数组大小
void func(const int (&arr)[10]);

// matraix指向数组的首元素，首元素是包含10个int类型的数组
// 注意形参声明时两侧的括号及第二维大小
void func(int (*matraix)[10], int row);
void func2(int matraix[][10], int row)；// 等价定义
```

#### 6.2.5 main：处理命令行选项

在 _main_ 函数中可以包含两个形参，用于处理命令行的选项，其定义形式为：

```cpp
// 第二个形参是一个数组argv，其元素为 C 风格类型的字符串
// 第一个形参表示数组argv中的元素个数
int main(int argc, char *argv[]) {

}

int main(int argc, char **argv) {

}
```

当从命令行中读取的实参传递给形参之后，argv 的第一个元素是指向所运行的程序的名称或者空字符串，然后才是命令行选项参数，同时必须保证最后一个指针之后的元素是 0。

:::tip

argv[1]才是真正的命令行选项参数！

:::

#### 6.2.6 含有可变形参的函数

C++ 实现可变形参有三种方式：

1. 如果所有实参类型相同，那么可以使用 _initializer_list_
2. 如果实参类型不同，那么可以使用模板编程中可变参数模板
3. 使用省略符形参，该方式一般用于与 C 函数交互的接口中

_initializer_list_ 定义在同名的头文件中，其实参数量未知，但是类型相同，具备下面操作

| 操作                                          | 详细                                                                      |
| --------------------------------------------- | ------------------------------------------------------------------------- |
| _initializer_list&lt;T&gt; lst ;_             | 执行默认初始化，T 类型的空列表                                            |
| _initializer_list&lt;T&gt; lst{a, b, c...} ;_ | 显示初始化，lst 的元素是对应初始值的副本，元素类型是 _const_              |
| <i>lst2(lst1) ;<br/>lst2 = lst1; </i>         | 拷贝或者赋值操作并不会 拷贝列表中的元素，<br> lst2 和 lst1 共享同一个对象 |
| _lst.size();_                                 | 列表中元素的数量                                                          |
| _lst.begin()_                                 | 列表首元素的指针                                                          |
| _lst.end()_                                   | 列表尾后元素的指针                                                        |

:::note

<ol>
  <li><i>initializer_list</i> 的所有元素永远都是常量类型；</li>
  <li><i>initializer_list</i> 作为形参时，其对应的实参必须放在花括号中；</li>
  <li><i>initializer_list</i> 作为形参的函数中也可以具有其他形参。</li>
</ol>

:::

省略符形参主要用于 C 函数交互的接口，使用时不会进行类型检查，包含了省略符形参的函数内部使用了 _varargs_ 的 C 标准库功能，大多数类型的对象在传递给省略符形参是都无法正确的拷贝，省略符形参只能出现在形参列表的最后一个位置，其形式如下：

```cpp
void foo(parm_list,...); // parm_list后的逗号可省略
void foo(...)
```

## 6.3 返回类型和 return 语句

### 6.3.1 无返回值函数

没有返回值的 _return_ 语句只能用在返回值是 _void_ 类型的函数中。但是返回值为 _void_ 的函数中可以不用写 _return_ 语句。可以使用 _void_ 类型的表达式作为返回值为 _void_ 函数中的 _return_ 语句的表达式。

#### 6.3.2 有返回值函数

有返回值的函数不是 _void_ 类型，其函数内部的 _return_ 语句中必须要携带返回值，而且返回值类型必须与定义的返回值类型相同或者可以相互转换。如果函数内部存在循环，在函数最后仍然需要一条 _return_ 语句。

返回值的方式与初始化一个变量或者形参的方式一致，返回的结果要么是被拷贝到新的变量的中，要么是通过引用或者指针的形式绑定到某个对象上，需要特别注意的是，由于块作用域问题，函数退出后函数内部的局部变量就会被销毁，因此==不能在函数最后返回局部变量的指针或者引用。==

> 函数的返回类型决定了函数调用的结果是左值还是右值，调用一个返回引用的函数得到左值，可以放置在赋值运算符的左侧，而其他返回类型得到右值。

C++ 11 规定，函数可以返回花括号包围的值的列表，类似于形参的初始化，返回的列表也会用来初始化返回值的临时变量，如果为空，那么返回值临时变量执行**值初始化**。如果返回值是内置类型，那么花括号包围的列表最多包含一个值。

对于 _main_ 函数，如果到达了结尾处也没有 _return_ 语句，那么编译器会隐式的插入一条返回值为 0 的 _return_ 语句。该返回值作为程序执行的状态，0 表示执行成功，其他则为执行失败。_cstdlib_ 头文件中定义了两个预处理变量 _EXIT_FAILURE_ 和 _EXIT_SUCCESS_ 。

### 6.3.3 返回数组指针

数组不能进行整体拷贝，因此函数无法直接返回数组，但是可以返回数组的指针或者引用。具体定义形式有以下四种方式：

1. 使用类型别名；
2. 直接定义；
3. 尾置返回；
4. _decltype_ 类型推导。

```cpp
// 使用类型别名的方式
typedef int arrT[10];
using arrT = int [10];
arrT *func(int i); // 返回值为一个指向10个整数的数组的指针

// 直接定义返回数组的指针的函数，与数组的定义相同，数组的维度必须知道
// 在函数中形参列表跟在函数名之后，然后才是数组的维度
int (*func(int i))[10]; // 注意必须具备最外层的括号

// C++ 11后可以使用尾置返回,尾置返回可以在任何函数中使用
auto func(int i) -> int (*)[10];

// decltype类型推导
int odd[] = {1,3,5,7,9};
decltype(odd) *arrPtr(int i); // decltype不会将数组类型转换成指针
```

## 6.4 函数重载

函数重载(_overload_)的定义是在**同一作用域内**的几个函数**名字相同**且**形参列表不同**。形参列表不同指的是形参个数或者形参的类型不同。

:::danger

函数重载需要注意以下几点内容：

- 函数的返回值不能作为函数重载的判断依据；
- 顶层 _const_ 形参在使用实参初始化时会忽略顶层 _const_ 属性，无法作为函数重载的判断依据；
- main 函数不能被重载；
- 类中的常成员函数可作为函数重载的判断依据

:::

```cpp
void func(int *pi);
// const对象不能进行类型转换，只能将const对象传递给const类型形参
void func(const int *pi); // 底层const可作为函数重载的判断依据
```

我们可以在函数重载中通过使用 `const_cast` 进行类型转换以减少重复代码。

```cpp
const string &func(const string &s){}

// 在非const的类型中使用const类型是安全的，而反过来则不安全
string & func(string &s) {
    auto &r = func(const_cast<const string &>(s));
    return const_cast<string &>(r);
}
```

在函数调用过程中会进行函数匹配，函数匹配就是在一系列候选函数中确定要调用的函数，这个过程也称作重载确定。函数重载的匹配最终只有三种结果：最佳匹配、无匹配及二义性调用。

函数重载不会影响到作用域，而名字查找优先于类型检查，因此内层作用域中的名字会隐藏外层作用域的同名实体。在不同作用域中并不是函数重载。

## 6.5 特殊用途语言特性

### 6.5.1 默认实参

函数形参中可以具有默认的初始值，这种形参称为默认实参。如果某个位置的形参具有默认的初始值，那么其后面位置的所有形参都必须具有默认值。在函数调用时，如果要使用默认实参，只需要在调用时忽略该位置的实参即可。

在给定的作用域中，一个函数的形参只能被赋予一次默认实参。赋予形参的默认实参不能使用局部变量，只要表达式的类型能够转换成形参的类型即可作为默认实参。用作默认实参的名字在函数声明所在的作用域内部进行解析，而这些名字的求值过程只会发生在函数调用时。

```cpp
int default_w = 10;
int size();
// func函数被调用时在会执行size()函数，
// 同样的，如果在func函数调用前修改了default_w的值，那么w的默认值也将被修改
void func(int w = default_w; int h = size());
```

### 6.5.2 内联函数和 constexpr 函数

**内联(inline)函数可避免函数调用时的开销，在函数定义时的返回值前添加关键字 _inline_ 即可将函数指定为内联函数，内联函数通常就是将它在每个调用点内联的展开，与宏替换有所区别。**

_constexpr_ 函数是指能够用于常量表达式的函数。C++ 11 定义 _constexpr_ 需要遵循以下几项约定：

- 函数的返回值类型及所有形参的类型都必须是字面值类型
- 函数体中必须有且只有一条 _return_ 语句

:::tip

将内联函数和 constexpr 函数放置在头文件中。

:::

### 6.5.3 调试帮助

_assert_ 是一种预处理宏，定义在 _cassert_ 头问题件中。 _assert_ 宏使用一个表达式作为它的条件，如果表达式的结果为假，_assert_ 会输出信息并且终止程序执行。 _assert_ 的行为依赖于一个名为 _NDEBUG_ 的宏，默认情况下并没有定义该宏。如果定义了 _NDEBUG_ ，那么 _assert_ 什么也不会做。

以下是调试时常用的预处理宏：

- \_\_func\_\_ : 表示函数名字
- \_\_FILE\_\_ : 表示文件名
- \_\_LINE\_\_ : 表示当前行号
- \_\_TIME\_\_ : 表示编译时的时间
- \_\_DATE\_\_ : 表示编译时的日期

## 6.6 函数匹配

函数匹配的过程：

1. 选定本次调用对应的重载函数集，也称为候选函数，候选函数具有下面 2 个特征：

   - 与被调用的函数同名
   - 函数声明在调用点可见

2. 考察调用的实参，从候选函数中选出可行的调用函数，可行的调用函数具有下面 2 个特征：

   - 形参数量与本次调用的实参数量相等，如果含有默认实参，那么允许实参数量少于形参数量
   - 每个实参的类型与对应形参的类型相同或者可以转换为形参类型

3. 从可行函数中选取与本次调用最匹配的函数，匹配的基本思想是实参类型与形参类型越接近，匹配越好，如果存在两个及以上的可行函数匹配一样好，编译器将报告二义性调用的错误信息。函数匹配的优先级如下所示，从上向下依次降低。

   - **精确匹配**：实参类型与形参类型相同或者实参从数组、函数转换为对应的指针类型或者向实参中添加、移除顶层 _const_
   - **通过 _const_ 实现的匹配**
   - **通过类型提升实现的匹配**
   - **通过算术类型转换或者指针转换实现的匹配**
   - **通过类类型转换实现的匹配**

   ```cpp
   void func(int);
   void func(short);
   func('0');// 字符0是小整型，调用时直接被提升至int类型，因此不会调用到接受short类型的函数

   void manip(long);
   void manip(float);
   manip(3.14); // 3.14是double类型，既能转换成long,也能转换成float，调用存在二义性

   void lookup(const string &s);
   void lookup(string &s);
   string a;
   const string b;
   lookup(a); // 直接调用非const版的函数,这是由于a是非const的，调用const版本涉及const转换
   lookup(b); // 直接调用const版的函数,非const版本的形参不能被const类型的实参初始化
   ```

## 6.7 函数指针

函数指针指向的是函数，而不是对象。函数的类型由函数的返回值类型和形参的类型共同决定，与函数名无关。当把函数名作为一个值使用时，函数名被自动转换成函数指针。在使用函数指针的时候可以无需解引用函数指针就直接调用函数。

```cpp
bool lengthCompare(const string &, const string &);
// pfunc指向接受两个const string类型参数，并返回bool的函数
bool (*pfunc)(const string &, const string &);

// 等价的方式
pfunc = lengthCompare;
pfunc = &lengthCompare;

// 等价的调用方式
bool b1 = pfunc("hello", "world");
bool b1 = (*pfunc)("hello", "world");
bool b1 = lengthCompare("hello", "world");
```

如果定义了函数指针指向重载函数，那么函数指针的类型必须与重载函数中某一个精确匹配。

函数指针可以作为函数的形参，此时，形参看起来是函数类型，但是实际使用的却是指针类型。直接使用函数指针较为繁琐，可以使用 _typedef_、_decltype_ 、_using_ 等方式简化。

```cpp
// typedef 函数类型，等价的方式
typedef bool Func1(const string &, const string &);
typedef decltype(lengthCompare) Func2;

// typedef 函数指针类型，等价的方式
typedef bool(*FuncP1)(const string &, const string &);
typedef decltype(lengthCompare) *Func2; // decltype推导的是函数类型，要声明为指针需要加 *

// 使用函数指针,等价的方式
void useBigger(bool pf(const string &, const string &)); // pf隐式转换为函数指针
void useBigger(bool (*pf)(const string &, const string &)); // pf显式定义为函数指针
void useBigger(FuncP1);
void useBigger(FuncP2);
```

函数指针也可以作为函数的返回值，表示返回指向函数类型的指针。与函数形参不同的是，我们必须将返回类型写成指针形式，编译器并不会自动将函数类型转换为函数指针类型。

```cpp
// using 函数类型
using Func = int(int *, int);

// using 函数指针类型
using FuncP = int(*)(int *, int);

// 声明返回函数指针，等价的方式
Fuac * func(int);
FuncP func(int);
// func是一个函数，返回的是一个指针，
// 指针指向的是参数类型是int *和int类型，返回类型是int类型的函数
int (*func(int))(int *, int); // 直接声明
auto func(int) -> int(*)(int *, int); // 尾置返回
int f(int *, int);
decltype(f) *func(int); // decltype类型推导
```
