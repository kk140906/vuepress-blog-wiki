---
title: 2. 变量和基本类型
date: 2017-08-20
category:
  - C++
tag:
  - 基本数据类型
  - 左值引用
  - const 修饰符号
article: false
---

## 2.1 基本内置类型

### 2.1.1 算术类型

基本内置类型包括算术类型(如字符、整型、布尔值、浮点数)和空类型(`void`)。

大多数计算机的可寻址的最小内存是字节(“Byte”),而基本的存储单元是字(“Word”)，通常一个字由多个字节组成，如 4 字节或者 8 字节等。

由于不同的计算机在处理内存的时候可能有所不同，因此 C++ 规定

- 一个`char`类型的大小至少与一个机器字节一样，通常`char`类型占据 1 个 Byte；
- 一个`int`类型的大小至少与一个`short`类型一样，通常`short`类型占据 2 个 Byte,`int`类型占据 4 个 Byte；
- 一个`long`类型的大小至少与`int`类型一样大，通常`long`类型占据 4 个 Byte；
- 一个`long long`类型的大小至少和`long`一样大，通常`long long`类型占据 8 个 Byte;
- 一个`float`类型的大小通常是 1 个 Word(4 个 Byte)，其有效位是 7 位;
- 一个`double`类型的大小通常是 2 个 Word(8 个 Byte)，其有效位是 16 位；

> 除此之外，对于字符和整型还有 `unsigned` 和 `signed` 之分，用以表示该数值大小是否为非负。但是其仅仅是个修饰作用，以告知计算机如何处理该类型的数据，并不改变其修饰的类型的大小。**特别地对于浮点数的计算优先选用 `double`类型，这是因为 `double`类型精度更高，并且在计算代价上与 `float`相差无几。**

### 2.1.2 类型转换

**为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址的数据类型，换言之，类型决定了数据所占据的字节数以及如何解释这些字节内容。**

如果使用了一种与目标类型不一致的类型进行赋值等操作则可能发生自动类型转换。

- 非`bool`类型 ---> `bool`类型： 0 为`false`，其他为`true`
- `bool`类型 ---> 非 `bool`类型： `false`为 0，`true`为 1
- 浮点数 --> 整数: 只保留浮点数的整数部分
- 整数 --> 浮点数: 浮点数的小数部分为 0
- 数值超过`unsigned`修饰的类型 --> `unsigned`修饰的类型：会将数值对`unsigned`类型的最大值做取余操作，余数就是结果
- 数值超过`signed`修饰的类型 --> `signed`修饰的类型：未定义的行为

> 不要混用 `unsigned` 和 `signed`类型进行运算
>
> - `signed`类型的取值如果是负，那么其会在运算中转换为 `unsigned`
> - 当从 `unsigned` 类型中减去一个值时必须保证其计算结果是非负。
>
> ```cpp
> unsigned int u = 10;
> int i = -42;
> cout << i + i << endl; // -84
> cout << u + i << enld; // i 被转换为 unsigned 后与 u 相加
>
> unsigned int u1 = 5, u2 = 6;
> cout << u1 - u2 << endl; // 数学计算结果为 -1, 其在计算中将表示为 0xffffffff
> ```

### 2.1.3 字面值常量

默认情况下，整型的十进制字面值是`signed`类型的，而八进制和十六进制则不确定。默认情况下：

- 十进制的字面值**类型**是`int`、`long`、`long long`中最小可容纳数据的那个, 42 的字面值类型为 `int`；
- 八或者十六进制的字面值**类型**是`int`、`long`、`long long`、`unsigned int`、`unsigned long`、`unsigned long long`、中最小可容纳数据的那个。

字符字面值常量是由单引号封闭起来的 char 类型字面值，而字符串字面值常量则是字符字面值常量组成的数组，编译默认在字符串的末尾添加*‘ \0 ’*字符。**如果两个字符串的字面值常量如果位置紧邻且仅由空格、缩进和换行分隔符组成，那么他们实际上一个整体。**

转义序列：转义序列被当做一个字符使用。

泛化的转义序列形式: _\\x_ 后紧跟 16 进制数字，或者 _\\_ 后紧跟一到三个的 8 进制数字

我们可以在实际使用的时候指定字面值常量的类型：

<table border=3>
    <th colspan=3>指定字面值类型</th>
    <tr><td><b>位置-符号</b></td><td><b>含义</b></td><td><b>类型</b></td> </tr>
    <tr><td colspan=3><b>字符及字符串</b></td></tr>
    <tr><td>前缀-u</td><td>Unicode 16字符</td><td>char16_t</td></tr>
    <tr><td>前缀-U</td><td>Unicode 32字符</td><td>char32_t</td></tr>
    <tr><td>前缀-L</td><td>宽字符</td><td>wchar_t</td></tr>
    <tr><td>前缀-u8</td><td>UTF-8字符</td><td>char</td></tr>
    <tr><td colspan=3><b>整型</b></td></tr>
    <tr><td>后缀-U</td><td></td><td>unsigned</td></tr>
    <tr><td>后缀-L</td><td></td><td>long</td></tr>
    <tr><td>后缀-LL</td><td></td><td>long long</td></tr>
    <tr><td colspan=3><b>浮点型</b></td></tr>
    <tr><td>后缀-F</td><td></td><td>float</td></tr>
    <tr><td>后缀-L</td><td></td><td>long double</td></tr>
</table>

<p class='div-border red'>由于小写的 l 与数字 1比较类似，推荐在整型和浮点类型时只使用大写，对于整型的 U和 L ，LL 可以组合使用。</p>

`bool`类型的字面值常量是`true`和`false`，而指针的字面值常量是`nullptr`。

## 2.2 变量

### 2.2.1 变量定义

变量定义的基本形式：_类型说明符 变量名 1, 变量名 2, …;_

其中类型说明符必不可少，而变量名至少一个，最后以分号结束该定义语句。我们可以在变量定义时对其进行初始化，在早期使用“=”进行初始化，这比较容易将初始化与赋值操作混淆。

> 初始化 - 创建变量的时候赋予其一个初始值；
>
> 赋值 - 把对象当前值擦除后使用一个新的值替换。

**C++11 以后可以统一使用“{ }”进行列表初始化。** 当使用列表初始化时，编译器会将“{ }”内部的所有参数转换成 _initializer_list&lt;T&gt;_ 的对象，而 _initializer_list_ 内部使用的 _array &lt;T,N&gt;_ 保存所有初始化值，如果初始化的对象支持 _initializer_list&lt;T&gt;_ 整体初始化，那么就进行整体初始化，否则就将参数进行拆解，根据匹配的构造函数进行参数传递。

**列表初始化会对初始值进行判断，如果初始值存在丢失数据的风险，编译器将报错。**

如果在定义时没有进行显式的初始化操作，那么变量会被默认初始化，

- 如果是内置类型，则根据定义的位置决定

  - 位于全局作用域中的内置类型被初始化为 0

  - 如果位于函数或者类内部，则是未定义，而静态的局部变量如果没有显示初始化则初始化为 0

- 如果是`class`类型，那么会调用默认的构造函数进行初始化操作。

### 2.2.2 变量声明与定义的关系

C++ 支持分离式编译(多个源文件分别编译，每个源文件称之为翻译单元)，因此支持将变量的定义与声明分开。

**声明**：让程序知道该变量的名字，

**定义**：在内存中创建与名字关联的实体，申请内存空间，还可能进行初始化。

**<u>一个变量只能被定义一次，但是却可以被声明多次</u>。**

**要想一个变量仅声明而不定义则可以使用关键字`extern`进行声明，并且不能进行显式初始化。**

```cpp
int i; // 声明并定义
extern int j; // 只声明
extern int k = 0; // 声明并定义，extern 关键字无效
```

### 2.2.3 标识符

C++标识符由字母、数字、和下划线组成，必须以字母和下划线开头，且对大小写敏感，标识符没有长度限制，但是不能使用与内置关键字名称相同的标识符。

对于标识符名称通常需要良好的规范，可以看看 Google 开源风格指南中对 C++的使用要求。

### 2.2.4 名字的作用域

通过变量的定义我们知道一个变量一定存在某个实体与之关联，但是出现在不同的位置的变量则与之关联的内存实体可能不同。那么 C++使用作用域对名字所关联的内存实体进行限定，通常使用“{ }”作为一个作用域。作用域分为全局作用域和块作用域，在块作用域内部中定义的变量通常是局部变量，离开块作用域就会销毁；而全局作用域则会直到程序结束才会销毁。作用域可以嵌套，位于内层作用域的变量会隐藏(遮蔽、覆盖)外层作用域中同名的变量。要想访问全局作用域的变量需要使用作用域访问符 _“::”_。

## 2.3 复合类型

复合类型是指基于其他类型定义的类型，这里只介绍左值引用与指针。前面提过变量的定义形式，其实更为通俗的描述是一条声明语句由一个类型说明符和紧随其后的一个声明符列表组成，而这里的声明符列表则类似于变量名，但是对于复合类型，该声明符实际是一个变量名及其与类型说明符关系的组合。

### 2.3.1 引用(左值引用)

左值引用的定义形式：_类型说明符 声明符(& 变量名 1) = 绑定的对象变量名 1, 声明符 (& 变量名 2) = 绑定的对象变量名 2;_

其中声明符由符号 “&”和变量名组合，而“&”则是变量与类型说明符之间的关系，表示变量名是对一个类型是类型说明符的对象的左值引用。左值引用是对已经存在的某个对象的一个别名，==**因此它并不是一个对象，定义一个引用之后，对引用的所有操作实际都是对所绑定的对象的操作。**==只能在定义的时候将左值引用绑定到对象上。一旦左值引用绑定后就不能再绑定到别的对象。

```C++
// 引用是对象的别名，其不是一个对象，因此不能定义引用的引用。
int i = 42;
int &ri = i; // 引用ri绑定到左值i上
// 我们不能直接定义引用的引用，但是却可以定义一个看似是引用的引用
// 下面的定义是一个看似是引用的引用，该定义是合法的操作，这是因为对引用的操作实际是对引用对象的操作，
// 因此，看似rri绑定到了一个左值引用ri上，实际上，rri绑定的却是ri的引用对象i
int &rri = ri;

int j = 5;
// 因为对引用的操作实际是对引用对象的操作,因此不可能再将引用绑定到别的对象上了
ri = j; // 该操作并不是将ri再绑定到别的对象，而是将j的值赋值给i。
```

**对于左值引用，其对所能绑定的对象进行了限制：**

- ==**不能绑定到需要进行类型转换的对象上**==。如，引用要绑定的对象是`int`类型，而定义引用的类型说明符却是`double`类型，这是两种不同的类型，不能进行绑定。但是针对这个却有两个*非常重要* 的例外的情况：
  1. **对`const`的左值引用可以接受任意表达式作为其初始值；**
  2. **为了多态的实现，可以将一个基类的指针或者引用绑定到派生类对象上。**
- ==**不能绑定到字面值常量,因为字面值常量是右值。**==
- **==不能绑定到返回右值的表达式上==**。

### 2.3.2 指针

指针的定义形式：_类型说明符 声明符( \* 变量名 1), 声明符( \* 变量名 1), …_

其中声明符是“ \* ” 与变量名的组合，而“ \* ” 则是变量与类型说明之间的关系，表示的是变量名是一个指向类型是类型说明符对象的指针。

指针也是一种复合类型，与引用类似，都实现了对其他对象的间接访问，但是与引用不同的是，指针是一个对象，允许对指针进行拷贝和赋值操作，可以再次指向别的对象，此外，指针也不需要在定义的时候就一定指定所指向的对象。

指针本身也是一个变量，变量的值是所指向的对象的地址，通过“&”操作符可以获取对象的地址，特别的，引用不是对象，因此不能定义一个指针去指向引用。如果指针指向的某个实际存在的对象就可以使用“ \* ”操作符去解引用指针以获取指向的对象。

```C++
int i = 42;
int &ri = i; // 引用
int *pi = &i; // 指针
int *&rpi = pi; // 对指针的引用
// int &*rpi = pi; // 指向引用的指针，非法的操作
int &ri_2 = *pi; // 引用,绑定到pi指向的对象
```

C++11 引入了新的一个字面值的指针(`nullptr`)来表示空指针，该关键字实际是一个 _std::nullptr_t_ 的类型，在早期是使用 NULL 或者 0 表示指针为空，但是这在使用时可能存在一定的误导，因此 C++11 引入了新的关键字表示空指针。

```C++
void func(int);
void func(void *);
// 对于上面两个函数重载，当使用NULL或者0去调用函数时，编译器可能会调用int类型形参的函数版本
// 但是如果我们希望调用指针形参的版本则无法正确调用
```

C++还有一种 `void *` 类型的指针，该指针可以存放任意类型的对象的地址。 `void *` 仅仅保存了对象的地址，而并不知道对象的实际类型，因此不能访问内存空间中的对象。

#### 2.3.3 理解复合类型的声明

变量的定义是一个类型说明符和一组声明符，在一条定义语句中，类型说明符只能有一个，而声明符可以有多种形式。要想理解某个定义的类型到底是什么，最简单的办法就是==从右向左阅读定义==，离变量名最近的符号对变量的类型有最直接的影响。

```C++
int i = 42;
// 从右往左阅读定义
int *pi = &i; // 离pi最近的是*,说明pi是一个指针，所指向的对象的类型是int类型
// 离ppi最近的是*,说明ppi是一个指针，所指向的对象的类型是一个复合类型，
// 然后再一步解析，在这个复合类型中最右侧的符号是个*，说明该复合类型也是一个指针
// 最后剩下的是基本的类型说明符，最终说明该变量是一个指向int类型的指针的指针
int **ppi = &pi;
 // 离rpi最近的是&,说明rpi是一个引用，所绑定的对象的类型是一个复合类型，
// 然后再一步解析，在这个复合类型中最右侧的符号是个*，说明该复合类型也是一个指针
// 最后剩下的是基本的类型说明符，最终说明该变量是一个指向int类型的指针的引用
int *&rpi = pi;
```

## 2.4 const 限定符

关键字`const`用于<u>_限定某个变量的类型_</u>，使其值不能被更改，相当于定义了一个**常量**。由于`const`限定的变量一旦创建，那么其值就不能更改，所以必须在定义的时候被初始化。

```C++
// 定义一个常量bufferSize
// const限定了变量bufferSize的类型是int类型的常量，
// 表示bufferSize这个变量(或对象)中所存储的值不能被更改

const int bufferSize = 512;
```

> `const`限定的变量与非 `const`限定的变量唯一的区别是 `const`限定的变量中所存储的值不能被更改，其所能够执行的操作除了不能修改变量的值以外与非 `const`限定的变量一致。

可以使用任意类型的表达式、字面值常量或者其他变量等对`const`限定的变量进行初始化。

```c++
// 定义一个变量i，初始化操作将字面量42复制给变量i
int i = 42;
// 定义一个常量ci，用变量i初始化常量ci，实际是将i的value(42)复制给常量ci
// 因此其不要求其初始化值必须是const，
const int ci = i;
// 定义一个变量j,用常量ci初始化变量j，实际是将常量ci的value(42)复制给变量j
int j = ci;
```

可以在“**运行时**”初始化`const` 限定的变量也可以在“**编译时**”就初始化`const` 限定的变量。

```C++
// 编译时就知道赋值操作符右边的值这在编译时就执行初始化
const int bufferSize = 512;
// 只在运行时才知道初始化值才能被初始化
const int bufferSize = get_size();
```

默认情况下，`const`限定的变量被认为<u>_仅在文件内部有效_</u>，当在多个文件中定义了含有相同名称的`const`限定的变量时，实际相当于在多个文件中分别定义了独立的变量，这些变量属于互不影响的。如果期望某个`const`限定的变量在别的文件中能够使用，那么需要在声明及定义的地方必须都添加`extern`关键字。同时，变量只能进行一次定义(或者初始化操作)。

```C++
// 在file1.cpp中定义一个常量bufferSize
// 在定义中添加extern关键字以表示常量可以被其他文件使用
extern const int bufferSize = 512;
// 在file2.cpp中声明常量bufferSize后即可使用与file1.cpp中相同的常量
// 在声明中添加extern关键字以表示常量在其他文件中被定义
extern const int bufferSzie;
```

### 2.4.1 const 的引用

`const`限定的实际是一个对象的类型,因此`const`的引用实际是把一个引用绑定到了`const`限定的对象上。而`const`限定的变量实际表示一个常量，其值不能被更改，因此这个引用被称之为**“对常量的引用”**。引用的本质是引用对象的别名，对引用的操作实际是对引用对象的操作，**<u>_对常量的引用不能用作修改它所绑定的对象_</u>**。==必须认识到的是，常量引用仅仅是对引用可以参与的操作做出了限定，对引用对象的本身未做任何要求，因此对常量的引用可以使用任意表达式作为初始值，只要表达式的值可以转换成内置的引用类型。**但是如果期望引用绑定到常量对象，只能使用常量引用**。==

> 为什么常量的引用不能被用来修改它所绑定的对象呢？这要从两个方面来看：
>
> - 假设常量的引用绑定的对象本身就是一个常量，那么常量的本质就决定了这个对象无论如何不能被更改；
>
> - 假设常量的引用绑定的对象本身不是一个常量，那么编译器会创建一个临时的常量，用来接受这个非常量的对象的值，然后再将常量引用绑定到这个临时的常量上，绑定到临时常量的引用自然也就不能用来修改这个非常量对象的值了。这也就解释了为什么常量引用作为对象的一个别名，却和引用绑定的对象有不一致的类型。
>
>   ```C++
>   // 定义一个变量i
>   int i = 42;
>   // 定义一个对常量的引用，使用变量i的值对其进行初始化
>   const int &ri = i;
>   // 引用作为引用对象的别名，就要求了引用与引用对象的类型必须一致，
>   // 上一语句中初始化时使用的是变量i的值，i是整型变量，
>   // 而ri是对int类型的常量的引用，两者明显不同
>   // 但是为什么上一语句是正确的初始化语句呢？
>   // 这是因为编译器对上一语句进行了转换，实际等价于下面两条语句:
>   const int tmp = i;  // 定义一个临时常量tmp，临时常量tmp可以使用非常量进行初始化
>   const int &ri = tmp; // 引用ri实际绑定的是临时常量tmp
>   ```
>
>   这里有个有趣的问题，既然引用 ri 实际绑定的是一个临时的常量 tmp,那么当 i 的值发生变化时，ri 的值应该如何变化呢？
>
>   经过验证发现的是：
>
>   - 如果 i 的基本数据类型与 ri 的基本数据类型一致，那么当修改 i 的值时，ri 的值会跟着变化，
>   - 如果 i 的基本数据类型与 ri 的基本数据类型不一致，那么当修改 i 的值时，ri 的值不会跟着变化。
>
>   造成这个现象的原因应该是由于类型不一致，必须做出类型转换，因此在创建临时常量的时候是实实在在的内存中开辟了一个新的空间用来存储转换后的值。(PS:具体原因并不知道，只是猜测。)

### 2.4.2 指针与 const

“**指向常量的指针**”与“**对常量的引用**”类似，<u>**_不能通过指向常量的指针修改所指对象的值_**</u>，==同样的，指向常量的指针也没有要求其所指向的对象类型，只是对指向常量的指针可以参与的操作进行了限定。==**但是如果期望存放常量对象的地址，只能使用指向常量的指针**。

```C++
// 定义一个double类型的常量pi
const double pi = 3.14;
// 定义一个指向常量的指针指向常量pi;
const double *cptr = &pi;
// 以下两条语句均不正确
// ptr是一个普通指针，意味着可以通过ptr修改pi的值，
// 但是pi是一个常量，其值不能更改，因此这种定义方式是不合法的
// double *ptr = &pi;
// cptr是一个指向常量的指针，其所指向的对象是一个常量，不能通过该指针修改其所指向的对象的值
// *cptr = 42;

// 定义一个double类型的变量pi
double pi = 3.14;
// 定义一个指向常量的指针cptr,然后用变量pi的地址对其进行初始化
const double *cptr = &pi;
```

指针是一个对象，因此可以像其他类型(`int`,`double`)的对象一样，可以把指针本身定义为一个常量，称之为“**常量指针**”，常量指针与常量类似，表示其值不能被更改，而常量指针的值实际是某一个对象的地址，那么常量指针实际表示的是该指针只能指向初始化时指向的对象，期间不能指向别的对象，这一点与引用类似，引用一旦绑定到某个对象，那么就不能再绑定到别的对象上。

```c++
// 定义一个int类型变量i
int i = 0;
// 定义一个常量指针ptr，用变量i的地址对其进行初始化
int *const ptr = &i;
// 定义一个double类型常量pi
const double pi = 3.14;
// 定义一个指向常量的常量指针cptr,用常量pi的地址对其进行初始化
const double *const cptr = &pi;


// 如果期望理清这些声明的含义，最有效的办法是从右向左理解
// 针对第二条语句，ptr的左边是const限定符，表明其是一个常量
// 而const限定符前面是一个指针声明符，表明其是一个常量指针
// 最左边的int表明这个常量指针所指向的对象是一个int类型对象

// 针对第四条语句，cptr的左边是const限定符，表明其是一个常量
// 而const限定符前面是一个指针声明符，表明其是一个常量指针
// 声明符之外的部分确定了对象的类型，紧接着的double表明其是指向的对象是一个double类型对象
// 最后的const限定符表明其所指向的double类型是一个常量
// 那么最终整个定义实际表明的是定义了一个指向double类型的常量对象的常量指针，
// 其所指向的对象及其所指对象的值均不能被更改
```

> 特别需要注意的是，指针声明符或者引用声明符都不是实际的基本类型，当 `const`限定符作用在其前面时实际修饰的是基本类型
>
> ```C++
> int i = 42;
> int const *p = &i; // const 实际修饰的是int类型，等价于const int *p = &i;
> ```
>
> 此外，还需注意区分“**常量指针**”和“**指向常量的指针**”的区别：
>
> - “**常量指针**”：表征的是所定义的指针只能指向一个对象，并没有限定是否能够通过该指针修改对象的值，
> - “**指向常量的指针**”：限定不能通过该指针修改所指向对象的值，因为所指向的对象可以理解为是一个常量(实际并没有限定所指对象必须是一个常量)，但是并没有限定该指针是否只能一直指向一个对象。

### 2.4.3 顶层 const

所谓顶层`const`指的是对任意数据类型的变量或对象的限定，表明该变量或对象为一个常量，其值不能被更改，而底层`const`则与指针、引用等复合类型的基本类型部分有关。更为通俗的说，==顶层`const`不能修改变量本身的值，而底层`const`则不能修改所指向的对象的值==。通常情况下，只有指针和引用存在底层`const`

```C++
// 定义一个int类型变量i
int i = 0;
// 定义一个常量指针ptr，用变量i的地址对其进行初始化
// 表明ptr指针只能指向变量i，ptr指针自身的值不能被更改，因此是一个顶层const
int *const ptr = &i;

// 定义一个int类型常量ci，ci的值不能被更改，因此是一个顶层const
const int ci = 42;
// 定义一个指向常量的指针cptr1，表明cptr1指针指向的对象是一个常量，因此是一个底层const
const int *cptr1 = &ci;
// 定义一个指向常量的指针cptr2，表明cptr2指针指向的对象是一个常量，因此是一个底层const
const int *cptr2 = &i;

// 引用作为对象的别名，要求引用的类型与其所绑定的对象具有一致的类型，因此常量的引用只能使用常量引用
const int &ri = ci;
```

==顶层`const`和底层`const`在拷贝操作时有一定区别，执行拷贝动作并不会影响被拷贝对象的值，因此顶层`const`会被忽略，而底层`const`则不能忽略，执行对象的拷贝时，必须要求拷入和拷出的对象具有相同的底层`const`，或者可以进行转换。==**这就是为什么对常量、常量的引用、指向常量的指针等在定义时进行初始化操作时并不要求初始化对象必须是常量的原因。**

```C++
// 定义一个int类型变量i
int i = 0;
// 定义一个常量指针ptr，用变量i的地址对其进行初始化
// 表明ptr指针只能指向变量i，ptr指针自身的值不能被更改，因此是一个顶层const
int *const ptr = &i;
// 定义一个int类型常量ci
const int ci = 42;
// 定义一个指向常量的指针cptr，用常量的地址对其进行初始化
// 表明cptr指针指向的对象是一个常量，其所指向的对象的值不能被更改，因此是一个底层const
const int *cptr = &ci;

// 合法的操作，ptr是一个顶层const，在拷贝时被忽略，p1是一个底层const
const int *p1 = ptr;
// 合法的操作，i是变量，p2是一个顶层的const
int *const p2 = &i;

// 不合法的操作,cptr是一个底层const，而p3不包含const限定符
// int *p3 = cptr;
// 不合法的操作,cptr是一个底层const，而p4不包含底层const限定符,只有顶层const限定符
// int *const p4 = cptr;
```

_其实区分顶层 `const`和底层 `const`只是为了区分 `const`限定的对象，只要在初始化或者后续的赋值操作中，可能存在修改由 `const`限定的对象的值就是非法的。例如上面指针中的 p3，指针也是一个对象。对象通常由两个部分组成，一个是这个对象的地址，另一个是这个对象所存储的值。p3 未加任何 `const`限定表明了 p3 的值可以被修改(例如**p3 = &i**)，从而可以指向不同的对象，同时也表明了可以修改 p3 所指向的值。假设 p3 初始化语句正确，那么 p3 所存储的值实际是 cptr 的副本，与 cptr 所存储的值一模一样, p3 与 cptr 不一样的地方仅仅是对象的地址不同。要想更改 p3 所指向的值只能通过 cptr 的副本进行更改，这就意味着可以通过 cptr 对其所指向的值进行更改，而 cptr 定义时限定了不能通过 cptr 对其所指向的值进行更改，这两者明显冲突，所以 p3 的初始化操作是非法的。_

#### 2.4.4 constexpr 和常量表达式

“**常量表达式**”是指值不会被改变并在==编译时==就能得到计算结果的表达式。

```C++
// 一个常量表达式要求，1，其值或计算得到的值是常量，即由const关键字进行限定
// 2，其值或计算得到的值是在编译过程中就能够得到的
// max_files是常量表达式
const int max_files = 20;
// limit是常量表达式
const int limit = max_files + 1;
// staff_size是变量，因此不是常量表达式
int staff_size = 20;
// sz只能在运行时获得值，因此不是常量表达式
const int sz = get_size();
```

==在 C++ 11 中新增关键字`constexpr`说明符来表明值或者返回值是常量表达式，并且可以在编译时进行优化，如果一个值是在编译期计算出来而不是运行时，那么它会使程序更快并且使用更少的内存。==

```C++
// 初始化max_files是使用字面值
constexpr int max_files = 20;
// 初始化lmit的值是能在编译时就计算出的常量结果
constexpr int limit = max_files + 1;
// 如果函数get_size()被定义为constexpr函数才是一条合法的语句定义，否则就是不合法的语句定义
// constexpr函数可以在编译期计算出结果，也可以在运行时计算出结果
// C++11规定，constexpr函数如果要在编译期就计算出结果需要具备两个条件，
// 1：函数的返回类型及所有实参的类型必须是字面值类型
// 2: 函数体中有且只有一条return语句

constexpr int sz = get_size();

constexpr int factorial(int n) {
    return n <= 1 ? 1 : (n * factorial(n - 1));
}
std::cout << "4! = ";
constN<factorial(4)> out1; // 在编译期就计算出结果了

volatile int k = 8; // 使用volatile禁止编译器优化后
std::cout << k << "! = " << factorial(k) << std::endl; //在运行时才计算结果
```

**`constexpr`要求在编译时就能计算出表达式的值**，因此对`constexpr`声明的变量类型有一定限制，通常为“**字面值类型**”，比如内置的基本数据类型、引用、指针等。

尽管指针和引用都能定义成`constrexpr`，但是它们的初始值都受到严格限制，==一个`constexpr`指针的初始值必须是`nullptr`、0、或者指向某个固定地址的对象==，*在函数体内定义的变量通常不是存在固定地址中，`constexpr`指针不能指向这样的变量。*定义与函数体外的对象或者在函数体内部使用了`static`修饰的变量是存放在固定地址的，因此可以用来初始化`constexpr`指针。

当满足以下两个条件的时候，一个引用也可以声明为`constexpr`：

1. 引用的对象是通过常量表达式进行的初始化
2. 在初始化过程中任何隐式的转换也是常量表达式

`constexpr`定义的指针属于常量指针，仅表示指针自身的值不能被更改，即不能再指向别的对象，而与所指向的对象的值没有关系。

```C++
// 函数体外定义全局变量a
int a = 1;
// 函数体内定义静态变量b
static int b = 2;
// 定义int类型常量j
constexpr int j = 42;
// 定义常量指针，必须使用常量表达式进行初始化
constexpr int *p = nullptr;
constexpr int *q = &a;
constexpr int *r = &b;
// 定义指向常量的指针的常量指针，必须使用常量表达式进行初始化
constexpr const int *m = nullptr ;

// 定义一个引用,可以通过该引用改变a的值，因为ra的constexpr可以看作顶层const，
// 顶层const意味着ra不能再绑定到别的对象，但是可以通过ra修改全局变量a的值
// 而是引用就决定了其不能绑定到别的对象，所以从这个层面讲，加不加constexpr是无关紧要的
// 对于引用constexpr实际限定的绑定的对象必须具备固定的地址
constexpr int &ra = a;
// 定义一个对静态常量的引用，使用constexpr const 进行限定，不能通过rc修改c的值
static const int c = 3;
constexpr const int &rc = c;
```

`const`限定符与`constexpr`限定符的区别

- ==**主要区别：`const`限定符可以在运行时才进行初始化，也可以在编译时进行初始化，而`constexpr`则要求在编译时初始化**==
- `const`限定符不要求用于初始化的对象为常量表达式，而`constexpr`则需要，如果初始化由构造函数执行，则构造函数也必须是`constexpr`
- `const`限定符既可以用作顶层`const`，也可以用作底层`const`，而`constexpr`只能用作顶层`const`
- `const`限定符修饰的指针可以指向非固定地址的对象，而`constexpr`指针只能指向具有固定地址的对象

## 2.5 处理类型

### 2.5.1 类型别名

有两种方法可以定义类型别名，传统的方法是使用`typedef`关键字，而 C++11 以后则可以使用“**别名声明**”。

别名声明形式：_using 别名 = 类型名;_

```C++
typedef double wages; // typedef定义别名
using wages = double; // 别名声明
```

如果某个类型别名表示的是复合类型或者常量，那么就需要格外注意 const 是对给定对象类型的修饰。

```C++
typedef char *p_string;
char a = 'A', b = 'B';
p_string pa = &a, pb = &b;

// p_string是char *的别名，const作用的是p_string

// 从右往左解读定义：cstr是一个p_string类型的常量，而p_string又是一个指向char类型的指针，
// 因此cstr实际是一个指向char类型的常量指针
const p_string cstr = 0;

// 从右往左解读定义：ps是一个指针，指向的是p_string类型的常量，因此ps首先是一个指向常量的指针
// 知道ps指向的是一个常量类型，而p_string又是一个指向char类型的指针，
// 因此ps实际是一个指向char类型的常量指针的指针
const p_string *ps;
```

### 2.5.2 auto 类型说明符

C++11 新标准引入了`auto`类型说明符，它能够让编译器==利用初始值==去推断表达式所属的类型，因此其必须要有初始值。使用`auto`推断多个变量的类型的时候要求多个变量的基本类型必须一致。

编译器推断的`auto`类型与初始值的类型有时候并不完全一致，这是因为为了更加符合初始化规则而做出的改变。

- 使用引用作为“**初始值**”，实际推断出的类型是引用对象的类型，因此 `auto` 无法直接推断出引用类型，如果需要定义引用类型变量，需要显示定义，如 `int i = 10; int &ri1 = i; auto &ri2 = ri1;`
- 使用`auto`**定义一个引用时**，初始值中的顶层`const`属性仍然保留
- 初始值中含有`const`限定时会忽略掉顶层`const`,保留底层`const`。要想`auto`推断的变量具有顶层`const`,必须在`auto`之前进行`const`限定

### 2.5.3 decltype 类型说明符

C++11 引入了第二种类型推断的说明符`decltype`，它的作用是在不实际执行表达式的条件下推断出表达式执行结果的数据类型。

如果`decltype`使用的表达式是一个变量，那么`decltype`返回该变量的类型，会保留`const`和引用，而`auto`处理顶层`const`和引用的时候则有所不同。

```C++
    const int ci = 42;
    const int &rci = ci;
    decltype(rci) rci_2 = rci; // 推断的类型仍然为const int &
// rci_2 = 5; // 错误const int &不能被用来修改对象的值
    auto rci_3 = rci; // 引用作为初始值，推断的类型是int
    rci_3 = 5;
    auto &rci_4 = rci; // 定义一个引用，推断的类型仍然是const int &
// rci_4 = 5; // 错误const int &不能被用来修改对象的值
    std::cout << ci << " "
              << rci << " "
              << rci_2 << " "
              << rci_3 << " "
              << rci_4;
```

如果`decltype`使用的是表达式而不是一个变量，那么`decltype`返回表达式结果的类型，但是有些表达式却向`decltype`返回一个引用类型。例如表达式是解引用操作，那么`decltype`将会得到对象的引用类型，这是因为对一个指针进行解引用操作后，我们不仅可以得到指针指向的对象，而且可以给该对象赋值，为此，_decltype( \* p)_ 推断的类型为对象的引用。

`decltype`与`auto`另一个不同的地方就是，如果是变量名加上了一层或者多层括号，那么该变量就变成了一个表达式，而变量又是一种可以作为左值的特殊表达式，因此`decltype`也会得到引用类型。

```C++
int i = 42, *pi = &i, &ri = i;
// decltype表达式是个表达式
decltype(*pi) ri = i; // 推断的类型是int &;
decltype((i)) ri_2 = i; // 推断的类型是int &;
// decltype定义返回值类型
template<typename T1,typename T2>
auto add(T1 x,T2,y) -> decltype(x+y);
```

## 2.6 自定义数据结构

C++11 标准规定可以为类的数据成员提供一个**类内初始值**，创建对象的时候，类内初始值被用于初始化数据成员，而没有初始值的成员则进行默认初始化。

> ==为类数据成员提供初始值的时候要么使用 “ = ”，要么使用 “ { } ”，绝对不能使用 “ ( ) ”。==

定义在函数体内部的类是“局部类”,但是局部类受到诸多限制，类一般不定义在函数体内，当定义在函数体外部时，如果要在不同文件使用同一个类，类的定义必须保持一致。
