---
title: 19. 特殊工具与技术
order: 19
category:
  - C++
tag:
  - 内存分配
  - 嵌套类
  - 类型识别
  - 枚举
  - union
  - 局部类
article: false
date: 2017-10-08
---

## 19.1 控制内存分配

### 19.1.1 重载 new 和 delete

某些应用程序对内存分配有特殊的需求，例如使用关键字 _new_ 将对象放置在特定的内存区域。

当我们使用 _new_ 表达式创建一个内存区域时，实际执行三个步骤了

1. _new_ 表达式调用 `operator new` 或者 `operator new[]` 的标准库函数，该函数内部调用 _malloc_ 分配一块足够大的、原始的、未命名的内存空间，然后进行 _static_cast_ 转型使其能够保存特定类型的对象或者对象的数组
2. 编译器运行相应的构造函数构造对象，并为其传入初始值
3. 对象构造完毕后返回一个指向该对象的指针

当我们使用 _delete_ 表达式删除一个动态分配的对象的时候，实际执行了二个步骤：

1. 对动态分配的对象执行析构函数
2. 编译器调用名为 `operator delete` 或者 `operator delete[]` 的标准库函数，该函数内部调用 _free_ 释放内存空间

如果需要自定义内存分配的细节，通常需要重载 `operator new` 函数和 `operator delete` 函数以控制内存分配的过程。可以将 `operator new` 和 `operator delete` 定义为成员函数，或者定义在全局作用域的函数，即使标准库中已经存在了这两个函数编译器也不会认为错误。

编译器查找 _new_ 和 _delete_ 的函数按照以下顺序：

- 首先判断分配或者删除的对象是否是类类型，如果是，则首先在类及其基类的作用域中查找，如果含有 `operator new` 成员函数或者 `operator delete` 成员函数则调用它们。
- 如果对象不是类类型或者在类及其基类的作用域中没有找到相应的函数，那么编译器在全局作用域中查找是否已经定义了自己版本的 `operator new` 或者 `operator delete` 函数。
- 如果在全局作用域中没有找到自定义的版本，那么就会调用标准库的版本。

标准库分别为 _new_ 和 _delete_ 定义了 4 个版本的重载函数，前 4 个版本可能抛出 _bad_alloc_ 异常，后 4 个版本不会抛出异常。_new_ 头文件中还定义了一个 _nothrow_ 的 const 对象，以请求 new 的非抛出异常的版本(`int *p = new (nothrow) int`)。同时，由于异常发生时的栈展开过程中会自动调用析构函数，那么通常析构函数中也不抛出异常。

```cpp
// 可能抛出bad_alloc异常
void *operator new(size_t);
void *operator new[](size_t);
void *operator delete(void*) noexcept;
void *operator delete[](void*) noexcept;
// 不会抛出异常，nothrow_t是定义在new头文件中的空struct
void *operator new(size_t,nothrow_t &) noexcept;
void *operator new[](size_t,nothrow_t &) noexcept;
void *operator delete(void*,nothrow_t &) noexcept;
void *operator delete[](void*,nothrow_t &) noexcept;
```

用户可以自定义上述 8 个版本中的任意一个，但是必须保证定义的版本是全局作用域或者类作用域，如果是类作用域的成员函数会隐式声明为 _static_ 的版本，因为 _new_ 和 _delete_ 分别工作于对象的构造之前和析构之后，必须是静态的成员函数，因此就不能操作类的任何数据成员。

在自定义 `operator new` 和 `operator new[]` 时，参数和返回值等必须满足以下要求：

- 函数的返回类型必须是`void *`,以保证可以向任意类型转换
- 第一个形参必须是 _size_t_,且不能具有默认值
- 单个对象的分配使用 _new_，将对象占据的字节大小传递给第一个形参
- 数组对象的分配使用 _new[]_，将存储在数组中所有元素占据的大小传递给第一个形参
- 当提供额外形参时，在使用自定义的 _new_ 表达式必须使用 _new_ 定位形式将实参传递给新增的形参
- 用户不能重载 `void * operator new (size_t, void *)`,该版本只能被标准库使用

对于 `operator delete` 和 `operator delete[]`，其要求返回类型必须是 _void_，第一个形参的类型必须是`void *` 。如果这两个函数被定义为类的成员函数，那么就可以包含另外一个类型为 _size_t_ 的形参，其初始值是`void *` 所指向的对象的字节数。

> 我们根本无法自定义 _new_ 和 _delete_ 表达式，实际上是重载的 `operator new` 和 `operator delete` 函数，因为无论 _new_ 或者 _delete_ 的执行过程都会调用这两个函数。

==当自定义了全局的 `operator new` 和 `operator delete` 后，这两个函数必须具备分配、释放内存的操作。_malloc_ 和 _free_ 就是一个纯粹的专门用于内存分配和释放的函数。==

```cpp
void *operator new(size_t size){
  if(void * p_mem = malloc(size))
    return p_mem;
  else
    throw bab_alloc();
}

void *operator delete(void * p_mem) noexcept {
  free(p_mem);
  p_mem = nullptr;
}
```

### 19.1.2 定位 new 表达式

`operator new` 和 `operator delete` 的功能与标准库 _allocator_ 类中的 _allocate_ 成员和 _deallocate_ 成员类似，他们负责**分配和释放内存空间**，但是**不会构造或销毁对象**。但是不同的是，`operator new` 分配的内存空间无法使用 _allocator_ 中的 _construct_ 成员构造对象，只能使用**定位 _new_**的形式构造对象。其具有以下几种常见形式：

- `new (place_address) type`
- `new (place_address) type (initializers)`
- `new (place_address) type [size]`
- `new (place_address) type [size] { braced initializer list}`

其中，_place_address_ 必须是一个指针。当只传入一个指针类型的实参时，定位 _new_ 表达式构造对象，但是不分配内存。

此外，传给 _construct_ 的指针必须指向同一个 _allocator_ 对象分配的内存，但是传递给定位 _new_ 的指针无须指向 `operator new` 分配的内存。

## 19.2 运行时类型识别

**RTTI**(_Run-Time Type Identification_)运行时类型识别通过两个运算符实现：

- **typeid**: 用于返回表达式的类型
- **dynamic_cast**:用于将基类的指针或者引用安全的转换成派生类的指针或者引用

**RTTI**通常应用于没有定义虚函数的时候期望使用基类的指针或者引用执行某个派生类的操作时。

### 19.2.1 dynamic_cast 运算符

_dynamic_cast_ 的使用形式，其中 _type_ 必须是类类型：

- _dynamic_cast &lt;type \*&gt;(e)_: e 必须是有效的指针
- _dynamic_cast &lt;type &&gt;(e)_: e 必须是一个左值
- _dynamic_cast &lt;type &&&gt;(e)_: e 不能是一个左值

除了上述要求外，e 的类型还必须符合以下三个条件的任意一个：

1. e 的类型是目标 _type_ 的公有派生类(派生类向基类的转换)
2. e 的类型是目标 _type_ 的公有基类(基类向派生类的转换)
3. e 的类型是目标 _type_ 的类型

对于指针类型的 _dynamic_cast_,如果转换失败则返回 0。因此通常在条件部分执行 _dynamic_cast_ 操作以确保类型转换和结果检查在统一表达式中完成。特别的，可以对一个空指针执行 _dynamic_cast_，返回的是 _type_ 类型的空指针。

对于引用类型的 _dynamic_cast_，如果转换失败则抛出 _bad_cast_ 异常。

### 19.2.2 typeid 运算符

_typeid_ 的使用形式：`typeid(e)`,其中 e 是任意表达式或类型的名字。其返回值是一个 _const type &_。而 _type_ 是标准库类型 _type_info_ 或者 _type_info_ 的公有派生类。

_typeid_ 的使用类似于函数形参，表达式的顶层 _const_ 被忽略，如果表达式是一个引用，则其运算结果是引用对象的类型。但是当其作用于数组或函数时并不会执行向指针类型的转换，例如，对数组 _arr_ 执行 `typeid (arr)`，那么所得到的的结果是数组类型，而不是指针类型。==如果运算对象不属于类类型或者不包含任何虚函数的类，其运算结果是运算对象的静态类型，当运算对象定义了至少一个虚函数的类的左值时，其结果在运行时才会求得==。

> 根据运算对象的类型，如果不是 class 类型，那么结果将是静态类型。如果运算对象是指针，那么返回的结果是该指针的静态编译时的类型。如果期望比较指针所指向的对象，则需解引用指针。

如果表达式的动态类型可能与静态类型不同，那么则必须在运行时对表达式求值。

### 19.2.3 使用 RTTI

通常，对于两个对象，如果他们的类型相同且对应的数据成员相同，那么则认为这两个对象相等。在类的继承体系中，每个派生类负责添加自己的成员，因此派生类的相等运算符必须把派生类的新成员考虑进来。可以使用**RTTI**先进行类型判断，然后再对各自的成员进行值判断。

```cpp
class Base{
  friend bool operator==(const Base&,const Base&);
protected:
  virtual bool equal(const Base&) const;
};
class Derived: public class Base{
protected:
  virtual bool equal(const Base&) const;
};

bool operator==(const Base &lhs, const Base &rhs){
  return typeid(lhs) == typeid(rhs) && lhs.euqal(rhs);
}

bool Base::equal(const Base &rhs) const{
  // 比较基类的成员
}

bool Derived::equal(const Base &rhs) const {
  auto derived_obj = dynamic_cast<const Derived &>(rhs);
  // 比较派生类的成员
}
```

### 19.2.4 type_info 类

_type_info_ 类的精确定义随着编译器不同而略有差异，至少提供下表的基本操作：

:::center

| type_info 的操作 | 说明                                                      |
| :--------------- | :-------------------------------------------------------- |
| t1 == t2         | 两个对象表示同一种类型，则返回 true                       |
| t1 != t2         | 两个对象表示不同类型，则返回 true                         |
| t1\.name()       | 返回一个 C 风格的字符串，表示类型的名字，名字与编译器有关 |
| t1.before(t2)    | t1 位于 t2 之前，则返回 true，顺序依赖与编译器有关        |

:::

_type_info_ 没有默认构造函数，而且其拷贝、移动构造函数以及赋值运算符都被定为删除的，创建 _type_info_ 对象的唯一途径是使用 _typeid_ 运算符。

## 19.3 枚举类型

枚举类型是一种新的类型，属于**字面值“整数”常量类型**。枚举类型定义时分为两类，一种限定作用域，定义方式:`enum class(struct) 枚举变量名{枚举成员1,枚举成员2,...};`另一种未限定作用域，定义方式:`enum 枚举变量名{枚举成员1,枚举成员2,...};`。

限定了作用域的枚举变量名不能省略，而未限定作用域的枚举变量名却是可选择的。如果省略了未限定作用域的枚举变量名，那么只能在定义 _enum_ 时定义它的对象，其对象是在定义 _enum_ 时的右侧花括号和最后的分号之间提供声明。

==在限定作用域的枚举类型中，枚举成员的名字遵循常规的作用域规则，并且在作用域外部不可访问。而未限定作用域的枚举类型，枚举成员的作用域与枚举类型本身的作用域相同。==

默认情况下，枚举成员的值从 0 开始，后续成员依次加 1，如果指定了某个成员的值，则后面的值从指定值依次加 1。枚举的两个成员都必须显式指定值成员的值的情况下可以指定相同的值。枚举的成员都是 _const_ 的，因此指定的值必须是常量表达式。

一个未限定作用域的枚举类型的对象或成员可以自动的转换成整型。

在 C++11 以后可以在枚举变量名后面添加冒号指定枚举成员的类型。

```cpp
enum A : unsigned long long {kCharType=255,kLongType=4294967295UL};
```

默认情况下，限定作用域的枚举类型的成员类型是 _int_，而未限定作用域的枚举类型不存在默认类型。

在 C++11 以后可以进行枚举类型的前置声明，但是前置声明必须指定其成员的类型。

```cpp
enum A : unsigned long long; // 显式指定为unsigned long long
enum class B; // 隐式指定为int
```

对于接受枚举类型的函数形参，其实参必须是枚举类型。由于未限定作用域的枚举类型可以自动转换成整型，在转换的过程中枚举对象和成员都被提升为 _int_。

## 19.4 类成员指针

“**成员指针**”是指可以指向类的非静态成员的指针。通常，指针指向一个类对象，而成员指针指向类的成员，而非对象。

### 19.4.1 数据成员指针

成员指针定义时必须包含所属的类，因此在&lowast; 之前添加类名::以表示当前定义的指针可以指向某个类的成员。在 C++11 以后可以使用 _auto_ 或 _decltype_ 进行类型推导

```cpp
// 指向一个常量(非常量的)对象A的const string成员的指针
const string A::*p_A_member;
// 初始化成员指针，取地址符作用域A类的成员而不是A类的对象
p_A_member = &A::content;
// auto 推导的方式,更加简洁
auto p_A_member2 = &A::content;
```

初始化一个成员指针或者为成员指针赋值的时候，该指针并没有指向任何数据，只有当解引用成员指针时我们才提供对象的信息。

与成员访问运算符 "**.**" 和 "**->**" 类似，也有两种成员指针的访问运算符："**.\***" 和 "**->\***"。

```cpp
A a, *p_a = &a;
auto p_A_memeber = &A::content; // 绑定初始化成员指针
auto A_member = p_a ->* p_A_member;// 在使用成员指针的时候指定对象a
```

常规的访问控制对于成员指针进行同样限制，数据成员通常是私有的，因此数据成员指针只能用在类的内部或者类的友元中。如果期望获取指向类私有成员的成员指针，可以在类内部定义一个静态函数返回数据成员指针。

### 19.4.2 成员函数指针

指向成员函数的指针与指向数据成员的指针定义方式类似，不过指向成员函数的指针需要指明目标函数的返回类型与形参列表，如果成员函数是 _const_ 成员，或者引用成员，则我们必须将 const 限定符和引用限定符包含进来。

```cpp
// 定义成员函数指针
char (A::*p_A_member)(A::pos,A::pos) const;
p_A_member = &A::get; // 必须显式使用取地址符
// 使用成员函数指针
A a, *p_a = &a;
// p_a ->* p_A_member括号必不可少
char A_member = (p_a ->* p_A_member)(10,5);// 在使用成员指针的时候指定对象a
```

成员函数指针的书写比较复杂，为了方便，可以使用 _using_ 或者 _typedef_ 定义类型别名。

```cpp
// pAMember是成员函数指针的别名，类型是指向A类的常量成员函数的指针
using pAMember = char (A::*)(A::pos,A::pos) const;
pAMember get = &A::get;
char A_member = get(10,5);
```

对于同种调用形式的成员函数可以利用成员函数指针可以形成一个函数调用表。

### 19.4.3 将成员函数用作可调用对象

成员指针不是一个可调用的对象，不能直接将一个指向成员函数的指针传递给标准库的算法。使用标准库的 _function_ 模板可以生成一个可调用的对象，在定义一个 _function_ 对象时必须指定对象的调用形式，如果可调用对象是一个成员函数，则第一个形参必须表示该成员是在那个对象上执行的。

使用 _function_ 需要知道成员的调用形式，可以使用标准库的 "mem_fn" 让编译器推断成员的类型，并且从成员函数指针生成一个可调用的对象。

此外还可以使用标准库的 "bind" 从成员函数指针生成一个可调用对象。

## 19.5 嵌套类

一个类可以定义在另一个类的内部，称之为“嵌套类”。嵌套类常用于定义作为实现部分的类。嵌套类是一个独立的类，与外层类基本没什么关系，外层类的对象和嵌套类的对象是相互独立的。

嵌套类的名字在外层类作用域中是可见的，但是在外层类作用域之外是不可见的。嵌套类也可以使用访问限定符来控制外界对其成员的访问权限。如果嵌套类中声明了一个静态成员，那么该成员需要在嵌套类的外层类的外部进行定义。

```cpp
// 嵌套类的声明
class TextQuery{
public:
    class QueryResult;
};
// 在外层类的外部定义一个嵌套类
class TextQuery::QueryResult{
public:
  QueryResult(std::string);
    static int mem;
};
// 在外层类的外部定义一个嵌套类的成员函数
TextQuery::QueryResult::QueryResult(std::string){}

// 外层定义静态成员
int TextQuery::QueryReult::mem = 1024;
```

## 19.6 union：一种节省空间的类

"**联合**" 是一种特殊的类，一个 _union_ 可以由多个数据成员，但是在任意时刻只有一个数据成员可以有值。当给 _union_ 中某个成员赋值之后，另外的成员就变成了未定义的状态。由于 _union_ 在任意时刻只有一个数据成员可以有值，因此它的存储空间至少能容纳其成员中最大的成员。

由于 _union_ 在任意时刻只有一个数据成员可以有值，而引用一旦绑定到对象就不能更改，因此 _union_ 中不能存在引用。默认情况下 _union_ 的成员默认是公有的。_union_ 不能作为基类，也不能继承自其他类，所以其不能包含虚函数。

_union_ 通常用于表示一组类型不同的互斥值。_union_ 的定义是以 _union_ 关键字开始随后是联合体的名字(名字是可以选择的)，最后是花括号内的一组成员声明。

```cpp
// 可以定义匿名的union，一旦定义一个匿名的union后，编译器就自动创建了一个未命名的对象
union{
  char c_val;
  int i_val;
};
// 未命名的结构体内成员的作用域与定义该union的作用域一致
c_val = 'h';
```

> 匿名的 union 不能包含受保护的成员或私有成员，也不能定义成员函数。

在 _union_ 内部使用类类型会比较复杂，当将一个类类型的成员改为其他内置类型的成员时会调用类的析构函数，而从内置类型的成员改为类类型的成员时会调用类的构造函数。因此通常把含有类类型成员的 _union_ 内嵌在另一个类中。

为了追踪 _union_ 中存储的值的类型，通常会定义一个独立的对象，该对象称为 _union_ 的判别式，为了保持 _union_ 与其判别式同步,需要将判别式也作为内嵌了 _union_ 的类的成员。

特别地，如果一个 _union_ 中包含了定义了析构函数的成员，外部类的析构函数并不清楚 _union_ 中存储的值是什么类型，则必须为定义一个析构函数将 _union_ 中的对应成员销毁。

## 19.7 局部类

定义在某个函数内部的类称为 "**局部类**",局部类定义的类型只在它的作用域内部可见，和嵌套类不同，局部类的成员受到严格限制，要求其所有成员都必须完整定义在类的内部。

局部类只能访问外层作用域定义的类型名、静态变量、以及枚举成员，如果局部类定义在某个函数内部，则该函数的普通局部变量不能被该局部类使用。外层函数对局部类的私有成员没有任何访问权限。

可以在局部类的内部再嵌套一个嵌套类，此时嵌套类也是局部类，必须按照局部类的要求定义。

## 19.8 固有的不可移植的特性

所谓的不可移植的特性是指因机器而异的特性，当程序从一个机器迁移到另外一个机器时这部分代码需要重写。

### 19.8.1 位域

类可以将其非静态的数据成员定义为位域，在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或者硬件设备传递二进制数据时，通常会用到位域。

位域的类型必须是整型或者枚举类型，通常使用无符号类型保存一个位域，位域的声明形式是在成员名字之后紧跟一个冒号以及一个常量表达式，该常量表达式表示指定成员所占据的二进制位。

```cpp
using unsigned Bit;
class File{
  Bit mode: 2;
  Bit moidfied:1;
};
```

在类的内部连续定义的位域压缩在同一整数的相邻位，从而提供存储压缩。

取地址符不能用于位域，因此任何指针都不能指向类的位域。

### 19.8.2 volatile 限定符

_volatile_ 的含义与机器相关，当对象的值可能在程序的控制或检测之外被改变时，应该将该变量声明为 _volatile_，以告诉编译器不应该对这样的对象执行优化。

_volatile_ 与 _const_ 非常类似，可以限定对象的类型，两者并不冲突，而 _const_ 与 _volatile_ 的重要区别就是我们不能使用合成的拷贝、移动构造函数及赋值运算符初始化 _volatile_ 对象或从 _volatile_ 对象赋值，合成的成员接受的形参类型是非 _volatile_ 的常量引用，如果我们希望拷贝、移动或者赋值它的 _volatile_ 对象，必须定义自己版本的控制成员，但是定义的控制成员是否有意义应当根据实际情况进行合理的判断。

```cpp
volatile int i; // i可能发生改变
volatile int arr[10]; // arr的每个元素都可能改变
volatile int *volatile p; // p是一个volatile的指针，指向的是volatile的int类型
```

### 19.8.3 链接指示：extern "C"

C++ 使用链接指示指出任意非 C++函数所用的语言，对其他语言的函数来说，编译器检查其调用的方式，与处理普通 C++函数的方式一致，但是生成的代码有所区别。

> `extern "C"` 引入的代码必须是 C++ 编译器所兼容的语言。

链接指示有两种形式：单个的和复合的。链接指示不能出现在类或函数定义的内部，同样的链接指示必须在函数的每个声明中都出现。

```cpp
// 单个形式
extern "C" size_t strlen(const char *);
// 复合形式
extern "C" {
  int strcmp(const char *,const char *);
  char *strcat(char *,const char *);
}
```

当一个 `#include` 语句被放在了复合链接指示中时，头文件中所有普通函数声明都被认定为链接指示的语言的编写的。链接指示是可以嵌套的，因此即使头文件中包含了链接指示也不会出错。

编写函数所用的语言是函数类型的一部分。对于链接指示定义的函数来说，它的每个声明都必须具有相同的链接指示，而且，指向其他语言的函数的指针必须与函数本身使用相同的链接指示。

```cpp
extern "C" void (*pf)(int); // 不能使用C++的函数指针与C的函数指针进行相互赋值、初始化等
```

链接指示作用于声明中的所有函数、返回类型或形参类型，如果希望给 C++函数传入一个指向 C 函数的指针，则必须使用类型别名。

```cpp
// FC 是一个指向C函数的指针
extern "C" typedef void FC(int);
// func是一个C++函数，其形参是指向C函数的指针
void func(FC *)
```

通过链接指示对 C++函数进行定义，可以令一个函数 C++函数在其他语言编写的程序可用。

```cpp
extern "C" double calc(double d) {}
```

链接指示与重载函数的相互作用依赖与目标语言，如果目标语言支持重载函数，那么为该语言实现链接指示的编译器很可能也支持重载 C++的函数。
