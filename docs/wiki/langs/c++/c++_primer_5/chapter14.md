---
title: 14. 重载运算与类型转换
order: 14
category:
  - C++
tag:
  - 运算符重载
  - 类型转换
article: false
date: 2017-09-26
---

## 14.1 基本概念

C++支持函数重载，这些函数在源代码中有相同的名字和不同的参数列表，链接器如何区分这些不同的重载函数之间的差异呢？这是因为编译器将函数名字及参数列表进行了组合编码，这个编码对链接器来说是唯一的名字，编码过程叫重整(_mangling_)，解码过程叫恢复(_demangling_)。

重载的运算符是具有特殊名字的 ==**函数**==，函数名字由关键字 _operator_ 后跟要重载的运算符号组成。重载的运算符参数个数与原生定义通常保持一致，一元运算符含有一个参数，二元运算符含有两个参数。特别地，针对二元运算符，第一个参数绑定到左侧运算对象，第二个参数绑定到右侧运算对象。如果重载的二元运算符是类的成员函数，那么类对象的 _this_ 指针绑定到左侧运算对象，而函数的参数则绑定到右侧运算对象。

:::note

运算符重载尽可能保证重载之后运算符的运算特性与未重载运算符的语义接近，避免滥用，导致行为异常。

:::

重载的运算符必须是已经存在的运算符，而且重载必须保证重载后的运算对象不能与未重载的运算对象出现冲突，例如

```cpp
// 重载加法运算符,由于加法运算符本身就支持两个整型对象的运算
// 重载后的加法运算符与本身发生了冲突，因此这种重载是错误的
int operator+(int, int);
```

大部分运算符都支持重载，但是出于其他原因通常不应该被重载，而某些运算符则不能被重载，下面归纳了大致情况：

:::tabs
@tab 支持

```cpp
+ - * / % ^ | ~ ! = < > <= >= ++ -- << >>
== != += -= /= %= ^= &= |= *= <<= >>=
[] () -> ->*
new new[] delete delete[]
```

@tab 支持但不建议

```cpp
// 运算符指定了运算对象的求值顺序，
// 而重载运算符本质是函数调用，无法保证继续以下几类运算符的求值顺序。
// 例如 && 与 || 运算符无法保证内置运算符的短路求值属性，重载后两个对象总会被求值。
// 而 , 和 & 对类具有特殊含义，重载会使行为异于常态。
& , && ||
```

@tab 不支持

```cpp
// 简单记忆：可认为除了 ! 之外，所有包含'.'字符形式的运算符都不能被重载
:: .* . ?:
```

:::

**运输符重载是否定义为类的成员函数通常有以下几个条件：**

1. 赋值 `=`,下标 `[]`,调用 `()`,成员访问箭头 `->` 和类型转换运算符必须定义为类成员函数；
2. 复合赋值运算符通常应该定义为类的成员函数，如 `+=`，`-=` 等；
3. 改变对象状态的运算符通常应该定义为类的成员函数，如递增、递减、解引用等；
4. 具有交换性或者对称性的运算符可能转换任意一端的运算对象，通常应该定义为类的非成员函数，如 `+`, `*`, `==` 等；
5. **用于输入输出的运算符必须定义为类的非成员函数**，否则运算符的左侧运算对象就绑定到类的对象上了，而实际用于输入输出的运算符的左侧运算对象必须是 **_iostream_** 对象；

```cpp
// 通常来说，为了避免麻烦，大部分运算符应该重载为类的成员函数
// 但是针对具有交换律或者对称性的运算符最好定义为类的非成员函数
// 例如标准库的string对象重载的 + 运算符
// 如果 '+'运算符重载为类的成员函数，那么就决定了 '+' 运算符的第一个对象必须是string对象
// 而s3 的运算的第一个对象不是string对象，因此此调用会发生错误
// 但是实际上由于加法的交换性,
// 第一个对象即使不是string对象也应该能够正确完成拼接，只是拼接的顺序与交换前相反
string s1 = "hello";
string s2 = s1 + "world";
string s3 = "world" + s1;
```

:::tip

大部分的的运算符都应该重载为类的成员函数，如果重载为类的成员函数，那么它的左侧运算对象就必须为所属类的一个对象。

:::

## 14.2 输入与输出运算符

输入`>>` 输出 `<<` 运算符是一个二元运算符，其左侧运算对象为 **_iostream_** 对象，右侧运算对象为需要输入或者输出的对象。**_==重载的输入输出的运算符必须定义为类的非成员函数==_**

- 重载输出 `<<` 运算符的第一个参数是 "非常量的 ostream 对象的引用" (_流状态会变化_)，而第二个参数是 "常量的引用"(_输出不需要变更变量的值_)，**返回值类型与第一个参数一致**；
- 重载输入`>>` 运算符的第一个参数是 "非常量的 istream 对象的引用" (_流状态会变化_)，而第二个参数是 "非常量的引用"(_输入内容需要改变变量的值_)，**返回值类型与第一个参数一致**；

在重载输入或者输出运算符时，有一些不同。由于输出运算符是将对象输出到标准输出流中，对输出的对象不会造成影响，因此不需要处理错误情况，而输入运算符从标准输入流中读取内容，写入到某个对象中，一旦在读取时发生错误，那么写入到对象中的值将是未定义的，因此在真正使用写入的对象时需要判断输入流是否发生错误。具体可能出现的错误如下：

- 输入流中读取的数据类型与即将写入的对象不匹配时会发生错误，例如从输入流中读取的是 _string_ 对象，而写入的是 _int_ 对象
- 当读取操作到达文件末尾或者遇到输入流的其他错误也会失败

```cpp
// 重载输出运算符,假设Sales_data类具有公有成员price
ostream& operator>>(ostream &os,const Sales_data &item){
  os >> item.price;
  return os;
}

// 重载输入运算符,假设Sales_data类具有公有成员price
istream& operator>>(istream &is,Sales_data &item){
  double price;
  is >> price;
  if(is) {
      item.price = price;
  }
  return is;
}
```

## 14.3 算术和关系运算符

大多数算术运算和关系运算通常具有对称性，可以允许左侧与右侧运算对象进行转换，因此大多定义为类的非成员函数。

**算术运算符：**

算术运算符返回的是局部对象副本的原因是算术运算符会计算它的两个运算对象得到新的运算对象，这个新的运算对象有别于任意一个运算对象。而且如果类需要定义一个算术运算符，通常会在类内部定义一个对应算术运算符的复合赋值运算符的成员函数，算术运算符通常使用复合赋值运算符来定义。

```cpp
Sales_data operator+(const Sales_data &lhs,const Sales_data &rhs){
  Sales_data sum = lhs;
  sum += rhs;
  return sum;
}
```

**关系运算符：**

通常情况下，大多数类都需要定义自己的相等运算符，以检验两个对象是否相等。对于类对象而言，两个对象是否相等应该比较对象的每一个数据成员，所有数据成员相等才能认为相等，对于有的类，还应该额外判断两个对象是否是同一个对象(即两个对象地址相同)。

:::note

如果某个类在逻辑上有相等性含义，那么就应该重载相等运算符及不相等运算符。相等和不相等运算符中的一个应该把工作委托给另外一个，保证只有其中一个负责实际对象比较工作，这样做的目的是避免相等和不相等的意义发生冲突，毕竟两个对象如果存在相等性含义，那么相等和不相等一定属于对立关系。

而对于比较关系运算符则因为标准库的原因大多重载小于关系运算符，一个类是否应该重载小于关系运算符通常由其比较的意义决定。

:::

## 14.4 赋值运算符

拷贝赋值和移动赋值运算符的右侧运算对象都是类对象，也可以定义右侧运算对象不是类对象的赋值运算符。例如 _vector_ 类中定义了第三种赋值运算符，这个运算符接受花括号的元素列表作为参数，具体使用形式：

```cpp
// 调用默认构造函数定义一个对象
vector<string> vs;
// 右侧运算对象不是vector<string>类型的，
// 调用赋值运算符既不是拷贝赋值运算符，也不是移动赋值运算符,而是自定义的赋值运算符
vs = {"a","b","c"};

// vector内部定义的其他赋值运算符基本定义如下StrVec类所示：
class StrVec {
public:
  StrVec & operator=(std::initialize_list<std::string> &il);
};
```

==赋值运算符必须定义为类的成员函数，复合的赋值运算符不要求必须是类的成员函数，但是通常定义为类的成员函数。==

## 14.5 下标运算符

类似容器功能的类通常需要定义下标运算符，通过下标运算可以获取容器内元素的值。为了与下标的原始定义兼容，下标运算符返回的是所访问元素对象的引用，返回值是左值，可以放在赋值运算符的任何一侧。同时，下标运算通常定义常量和非常量两个版本,当类是常成员类时可以调用常量版本的下标访问元素，不能为其赋值。

```cpp
class StrVec{
public:
  std::string & operator[](std::size_t n);
  const std::strng & operator[](std::size_t n) const;
};
```

## 14.6 递增和递减运算符

具有类似迭代器功能的类通常会实现递增和递减运算符，这两种运算符不要求必须是成员函数，但是由于更改的对象就是类对象本身，所以通常定义为类的成员函数。递增和递减运算符分为前置和后置两个版本，为了与内置运算符兼容，前置和后置版本的运算符的返回值类型应该满足以下条件：

- 对于前置递增和递减运算符，其应该返回修改后的操作对象的引用，以便对该对象进行别的操作
- 对于后置递增和递减运算符，其应该返回为修改前的操作对象的副本

由于前置版本和后置版本使用的是运算符符号相同，运算对象类型和数量也相同，那么就无法通过简单的函数重载区分前置和后置，为了解决这个问题，后置版本会接收一个额外的 _int_ 类型的形参，这个形参在实际使用中不需要使用，当需要使用后置版本的运算符时，编译器为这个形参提供一个值为 0 的实参。如何区分前置和后置，示例如下：

```cpp
class StrBlobPtr{
public:
  StrBlobPtr & operator++(){
    ++curr_pos;
    return *this;
  }
  // int 形参通常不被实际使用
  StrBlobPtr operator++(int){
    auto ret = *this;
    // 调用前置递增运算符
    ++*this;
    return ret;
  }
private:
  int curr_pos;
};
```

## 14.7 成员访问运算符

成员访问运算符是一个特殊的运算符，编译器在处理成员访问运算符(假设执行语句：`p->a`)过程按照递归的方式执行：

1. 如果 p 是指针类型，那么就调用内置的箭头运算符，等价于`(*p).a`，如果 p 所指的对象中没有 a 那么则程序错误;
2. 如果 p 是重载了`->`的类对象，那么会调用重载函数的返回结果去获取对象 a，等价于`p.operator->()->a`。根据调用重载函数返回的结果，编译器会继续递归判断该结果是指针还是重载了`->`的类对象，如果是指针，那么就执行第 1 步，否则执行第 2 步

基于整个执行过程，我们可以知道递归终止的条件就是最内层的对象类型是指针类型。因此为了保证`->`能够正确执行，重载的`->`运算符的返回值必须是指针类型或者是重载了`->`的类对象指针。成员访问右侧的运算对象取决于重载`->`的返回值类型，如果返回值为当前类的指针，那么可以通过`->`访问当前类的公有成员，如果是别的类指针，那么可以访问别的类的公有成员。举个例子简单说明一下重载的成员访问运算符的执行过程。

```cpp
// 定义一个类Ptr
class Ptr{
public:
  static int a;
  Ptr* operator->(){
    std::cout << "调用重载函数operator->()" << std::endl;
    return this;
  }
};

// 假设类Ptr是最内层的一个类，在主函数定义一个Ptr对象去访问类中静态成员对象a
int Ptr::a = 10;
Ptr p1;
// 重载的->等价于函数调用
// 那么对于p1->a实际等价于(p1.operator->())->a;
// 先执行调用重载函数p1.operator->()，其返回的结果为对象的指针ret,
// 根据其递归终止条件，然后会调用内置的箭头运算符,
// 解引用重载函数的返回结果ret，然后获取其成员对象 a
std::cout << p1->a << std::endl;
```

:::tip

如果重载的 `->`运算符返回值为对象本身，而不是指针，那么会接着执行 `->`操作。由此将会进入无限递归，这个错误(gcc error:circular pointer delegation detected)在编译时就被编译器识别。

:::

## 14.8 函数调用运算符

如果类重载了函数调用运算符，那么该类的对象被称作 "**==函数对象==**"，因为这种对象可以被调用，调用行为类似于 "调用函数一样"。

```cpp
// 假设定义一个类，可以返回给定整型变量的绝对值
struct absInt{
  int operator()(const int i) const {
    return i < 0 ? -i : i;
  }
};
// 那么对absInt类对象的使用就可以像函数调用一样
absInt absInt_obj;
// 等价于absInt_obj.operator()(-40);
int absI = absInt_obj(-40);
```

==函数调用运算符必须重载为类成员函数，一个类中可以根据函数重载的原则定义多个不同版本的函数调用运算符。==

_lambda_ 表达式的本质就是函数对象，编写一个 _lambda_ 表达式后编译器会将这个表达式翻译成一个未命名类的未命名对象。

_lambda_ 表达式不捕获参数时，在等价的类中就不需要额外的数据成员来存储参数：

```cpp
// 定义一个lambda表达式
auto tmp = [](const int i,const int j) -> bool {return i < j;};

// 其等价的类定义如下
struct Less{
  bool operator()(const int i, const int j){
    return i < j;
  }
};

Less less;
std::cout << less(3,5);
```

_lambda_ 表达式捕获参数时，在等价的类中就需要额外的数据成员来存储参数：

```cpp
// 定义一个lambda表达式，捕获局部变量s的值
std::string s = "hello";
auto tmp = [s](const int i,const int j) -> bool {
  std::cout << s << std::endl;
  return i < j;
};

// 其等价的类定义如下
class Less{
public:
  // 通过构造函数捕获局部变量的值
  Less(const std::string &str) : s(str) {}
  bool operator()(const int i, const int j){
    std::cout << s << std::endl;
    return i < j;
  }
private:
  std::string s;
};
Less less("hello");
std::cout << less(3,5);

```

lambda 表达式产生的类不含默认的构造函数，默认的赋值运算符及默认的析构函数，而是否包含默认的拷贝/移动构造函数通常要视捕获的数据成员类型决定。

标准库定义了一些常用的函数对象:

:::center

| 算术运算               | 关系运算                  | 逻辑运算                |
| :--------------------- | :------------------------ | :---------------------- |
| plus&lt;Type&gt;       | equal_to&lt;Type&gt;      | logical_and&lt;Type&gt; |
| minus&lt;Type&gt;      | not_equal_to&lt;Type&gt;  | logical_or&lt;Type&gt;  |
| multiplies&lt;Type&gt; | greater&lt;Type&gt;       | logical_not&lt;Type&gt; |
| divides&lt;Type&gt;    | greater_equal&lt;Type&gt; |                         |
| modulus&lt;Type&gt;    | less&lt;Type&gt;          |                         |
| negate&lt;Type&gt;     | less_equal&lt;Type&gt;    |                         |

:::

需要特别注意的是，标准库的函数对象的运算对象类型必须是同种类型，而且标准库规定其函数对象对于指针同样适用。为什么标准库对于指针会同样适用，而普通的类对象实现就不行呢？
C++ Primer 以比较两个无关指针的问题进行举例，比较两个无关指针将产生未定义的行为。

```cpp
// 假设定义两个变量,使用lambda比较
std::string s1 = "hello";
std::string s2 = "50";
auto compare = [](const std::string *ps1,const std::string *ps2) {
  return ps1 < ps2;
};
// 未定义的行为
std::cout << compare(&s1,&s2) << std::endl;
// 使用标准库函数定义的函数对象
less<std::string *> l;
std::cout << l(&s1,&s2) << std::endl;
```

标准库在实现 less 类的函数调用运算符时进行了识别，如果比较的结果不是内置的常量类型就会将对象转换成 uintptr_t 类型进行比较

```cpp
// 标准库less实现方式
template<typename _Tp>
struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
{
  _GLIBCXX14_CONSTEXPR bool
  operator()(_Tp* __x, _Tp* __y) const _GLIBCXX_NOTHROW
  {
    if (__builtin_constant_p (__x < __y))
      return __x < __y;
  return (__UINTPTR_TYPE__)__x < (__UINTPTR_TYPE__)__y;
  }
};
```

另外一个需要注意的是，在 set 或者 map 中标准库函数对象使用的类型是 key_type

**C++有以下几种可调用的对象：**

- 函数
- 函数指针
- _lambda_ 表达式
- _bind_ 创建的对象
- 重载了函数调用运算符的类

可调用的对象也有自己的类型，但是不同类型的可调用对象可能共享同一种 "**调用形式**"。如`int (int, int)`

对于同一种调用形式的对象有时候经常会创建一个 "**函数表**"，用于存储指向这些可调用对象的“_指针_”。通过 _map_ 可以非常容易就实现函数表的功能。但是 _map_ 内的元素类型必须相同，而可调用对象又具有不同的类型，这就导致了无法把所有同种调用的形式的对象都添加到 _map_ 中。因此标准库提供了一个 _function_ 类型解决这个问题，_function_ 是一个模板类，_function_ 具有以下几个常用操作：

:::center

| 用法                          | 详细说明                                                          |
| :---------------------------- | :---------------------------------------------------------------- |
| function&lt;T&gt; f;          | 定义一个空的 function，用来存储可调用对象，**T 表示一种调用形式** |
| function&lt;T&gt; f(nullptr); | 显式构造一个空的 function                                         |
| function&lt;T&gt; f(obj);     | 在 f 中存储可调用对象的 obj 的副本                                |
| f                             | 可以将 f 当做一个条件，当包含可调用对象时为真，否则为假           |
| f(args)                       | 调用 f 中的对象，参数是 args                                      |

:::

```cpp
// 定义一个可以存储int (int,int)调用形式的函数表,这个函数表就可以保存不同类型的可调用对象了
int add(int,int);
int divide(int,int);
map<std::string,funciton<int(int,int)>> ops;
ops.insert({"+",add});
ops.insert({"/",divide});
ops.insert({"%",[](int i,int j){return i % j;}});
// 调用
std::cout << ops["+"](3,2) << std::endl;
std::cout << ops["/"](3,2) << std::endl;
std::cout << ops["%"](5,3) << std::endl;

// 上面的函数表添加新的元素的时候有个问题，函数名实际是一个地址，如果存在同名的函数重载，
// 那么编译器在插入的时候就会检测到存在一个函数名字但是却对应了两个地址，
// 它不知道应该把哪个地址添加进去
// 为了解决这个问题，可以通过定义函数指针指向我们要添加的函数，或者使用未命名的lambda表达式。
float add(float,float);
using INTFUNC_P = int(*)(int,int);
INTFUNC_P addInt = add;
ops.insert({"+",addInt});
ops.insert({"+",[](const int a,const int b){return a + b;}});
```

存在函数重载的函数不能直接添加在函数表中，最有效的方式是通过定义一个函数指针指向我们要添加的函数或者使用未命名的 _lambda_ 表达式等。

:::warning

如果添加的函数是类的成员函数，那么成员函数应当声明为 _static_ 的。这是因为类的成员函数的第一个参数是隐含的 _this_ 指针，直接添加会造成与调用形式不匹配的情况。

:::

## 14.9 重载、类型转换与运算符

"**转换构造函数**" 和 "**类型转换运算符**" 共同定义了 "**类类型转换**"，有时也称为 "**用户定义的类型转换**"。

“==类型转换运算符==”是类的特殊成员函数，它负责将一个 _class_ 类型的的对象转换成其他类型，类型转换函数的形式为：

`operator type() const;`

其中，_type_ 为某种(除了 _void_)转换类型，只要该类型能做为函数的返回值类型即可，如 _int_, _float_,其他 _class_ 类型等。需要注意的是，数组和函数类型不能直接做为函数返回值，因此不允许转换成数组和函数类型，而数组的指针及函数的指针或者引用类型可以作为返回值，因此不会受到限制。

此外，_class_ 类型转换运算符不能有显式的返回值类型，因为返回值类型由转换类型(_type_)隐式决定。同时，它也不能有形参列表，因为类型转换是隐式执行的，无法传递实参。而且 _class_ 类型转换通常不会改变要转换的对象的内容，因此通常为 _const_ 成员。

编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准(内置)类型转换之前或之后，并与其一起使用。

```cpp
class SmallInt{
public:
  // 构造函数，int类型转换为class类型
  SmallInt(const int i = 0) : val(i) {
    if (i < 0 || i > 255) {
      throw std::out_of_range("Bad SmallInt value");
    }
  }
  // 重载类型转换运算符，class类型转换为int类型
  operator int() const { return val; }
private:
  std::size_t val;
};

// 定义一个SmallInt对象
SmallInt sm;
// 编译器会利用内置的类型转换隐式的将3.14转换成int类型，
// 然后调用合成的拷贝赋值运算符转换成class类型的对象
sm = 3.14;
// 编译器利用重载的类型转换运算符将class类型转换成int类型
// 然后利用内置类型转换将int类型转换为double类型
std::cout << sm + 3.14 << std::endl;
```

C++11 标准引入了 "**显示的类型转换运算符**"，使用 _explicit_ 关键字修饰类型转换运算符，这就意味着编译器不会进行隐式转换，防止错误转换。但是如果表达式应用在 "**if, while, do..while, for**" 等语句的条件部分以及 "**!, ||, &&, ? :**" 等运算上仍然会执行隐式类型转换。

```cpp
class SmallInt{
public:
  // 构造函数，int类型转换为class类型
  SmallInt(const int i = 0) : val(i) {
    if (i < 0 || i > 255) {
      throw std::out_of_range("Bad SmallInt value");
    }
  }
  // 显式声明的重载类型转换运算符，class类型转换为int类型
  explicit operator int() const { return val; }
private:
  std::size_t val;
};

// 定义一个SmallInt对象
SmallInt sm;
// 编译器会利用内置的类型转换隐式的将3.14转换成int类型，
// 然后调用合成的拷贝赋值运算符转换成class类型的对象
sm = 3.14;
// 这会报错，类型转换是显示声明的，不会进行隐式转换
// std::cout << sm + 3.14 << std::endl;
std::cout << static_cast<int>(sm) + 3.14 << std::endl;
```

IO 标准库也是显式定义的向 _bool_ 类型的转换 ,与上面的规则一致，在某些情况下也会隐式转换。如 `while(std::cin >> value)`，将数据读入到 value 后 "std::cin" 隐式转换为 _bool_ 类型用于 _while_ 的条件判断。

==如果类中包含一个或者多个类类型转换，那么必须保证在类类型和目标类型之间只存在唯一的转换方式。==

以下情况可能产生多重转换路径：

- 两个类提供相同的类型转换；例如 A 类定义了一个接受 B 类对象的转换构造函数，同时 B 类定义了一个目标类型是 A 类的类型转换运算符。
- 类定义多个转换规则，而这些转换涉及的类型本身通过其他类型转换联系在一起。
- 多个类定义了同一种可行的匹配。

```cpp
// 二义性举例1：
struct B;

struct A {
  A(const B &); // 构造函数把一个B转换成A
};

struct B{
  operator A() const; // 类型转换运算符，B转换为A
};

A f(const A&);
B b;
// 这就会有一个二义性错误
// 函数f接收的是一个A类型的常引用，而传递的实参是B类对象b
// 而A的构造函数和B的类型转换运算符都可以把一个B的类对象转换成A的对象，造成二义性错误
A a = f(b);


// 二义性举例2：
struct C{
  C(int = 0);
  C(double);
  operator int() const;
  operator double() const;
};

void f2(long double);
C a;
// f2的形参是long double类型，而C重载了2个类型转换运算符，分别为int，和double，
// 这两个目标类型与long double类型都不是精确匹配，因此会造成二义性问题
f2(a);

long lg;
// lg是long类型，而C的构造函数有两个，一个是int，一个是double，
// 这两个都不是long类型的精确匹配。造成二义性问题
C a2(lg);


// 二义性举例3：
struct D{
  D(int);
};
struct E{
  E(int);
};

void f3(const D &);
void f3(const E &);

// 函数f3定义了接受D和E类型的形参，而这两个类都定义了接受int的构造函数，
// 而这两个构造函数各自匹配了重载的f3的一个版本，造成无法区分调用哪个f3的二义性问题
f3(10);

// 二义性举例4：
struct F{
  F(double);
};

void f4(const D &);
void f4(const F &);
// 函数f4定义了接受D和F类型的形参，
//而这两个类提供了可行的匹配，编译器会认为这两个可行的匹配匹配程度一样。
f4(10);
```

如果定义的类型转换函数之前或者之后存在内置的类型转换，那么内置的类型转换会决定函数的最佳匹配。**==除了显式的向 _bool_ 类型转换外，应当避免定义类型转换，并尽可能限制可能出现转换问题的非显式构造函数==**

如果同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，那么将会遇到重载运算符与内置运算符的二义性问题。

```cpp
class SmallInt{
    // 重载+运算符
friend operator+(const SmallInt &, const SmallInt &);
public:
  SmallInt(int = 0);
  // class类型转换为int类型
  operator int() const {return val;}
private:
  std::size_t val;
};

SmallInt s1, s2;
// 使用重载的 + 运算符
SmallInt s3 = s1 + s2;
// 存在二义性问题
// 1.可以调用类型转换将class类型转换为int类型，然后调用内置的 + 运算符；
// 2.可以将0转换为SmallInt的对象，然后使用重载的+运算符；
int i = s3 + 0;
```
